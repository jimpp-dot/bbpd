From 17c495707a14b526bd5c981d4ef70972d4bcaead Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E7=8E=8B=E5=8B=87?= <wangyong@meizu.com>
Date: Mon, 22 Aug 2022 21:28:10 +0800
Subject: [PATCH] 1.flutter_webview_oldv2.0.10_diff

---
 packages/webview_flutter/android/build.gradle |    5 +-
 .../android/src/main/AndroidManifest.xml      |   11 +-
 .../webviewflutter/DisplayListenerProxy.java  |    4 -
 .../webviewflutter/FileChooseActivity.java    |   93 ++
 .../webviewflutter/FlutterCookieManager.java  |    2 +-
 .../webviewflutter/FlutterWebView.java        |  213 ++-
 .../webviewflutter/FlutterWebViewClient.java  |  777 ++++++----
 .../webviewflutter/InputAwareWebView.java     |   22 +-
 .../webviewflutter/JavaScriptChannel.java     |    2 +-
 ...readedInputConnectionProxyAdapterView.java |    2 +-
 .../webviewflutter/WebViewFactory.java        |   21 +-
 .../webviewflutter/WebViewFlutterPlugin.java  |   48 +-
 .../example/android/app/build.gradle          |    4 +-
 .../gradle/wrapper/gradle-wrapper.properties  |    3 +-
 .../EmbeddingV1ActivityTest.java              |   18 -
 .../android/app/src/main/AndroidManifest.xml  |    9 +-
 .../webviewflutterexample/MainActivity.java   |    7 +
 .../MainApplication.java                      |    7 +
 .../main/res/xml/network_security_config.xml  |    4 +
 .../app/src/main/res/xml/provider_paths.xml   |    5 +
 .../example/android/build.gradle              |    5 +-
 .../gradle/wrapper/gradle-wrapper.properties  |    2 +-
 .../webview_flutter_test.dart                 |   22 +-
 .../ios/Flutter/AppFrameworkInfo.plist        |    2 +-
 .../ios/Runner.xcodeproj/project.pbxproj      |    8 +-
 .../xcshareddata/xcschemes/Runner.xcscheme    |    2 +-
 .../webview_flutter/example/lib/main.dart     |   20 +-
 .../webview_flutter/example/lib/main1.dart    |  127 ++
 .../webview_flutter/example/lib/testWeb.dart  |  524 +++++++
 packages/webview_flutter/example/pubspec.yaml |    2 +-
 .../ios/Classes/FLTGestureInterceptView.h     |   18 +
 .../ios/Classes/FLTGestureInterceptView.m     |   76 +
 .../ios/Classes/FLTWKNavigationDelegate.m     |   51 +
 .../ios/Classes/FlutterWebView.m              |   99 +-
 .../ios/Classes/JavaScriptChannelHandler.h    |    2 +
 .../ios/Classes/JavaScriptChannelHandler.m    |    9 +
 .../ios/Tests/FLTWebViewTests.m               |   38 +
 .../ios/webview_flutter.podspec               |    7 +-
 .../lib/platform_interface.dart               |  118 +-
 .../lib/src/webview_android.dart              |   17 +-
 .../lib/src/webview_cupertino.dart            |   12 +-
 .../lib/src/webview_method_channel.dart       |  112 +-
 .../webview_flutter/lib/webview_flutter.dart  |  307 ++--
 packages/webview_flutter/pubspec.yaml         |   29 +-
 .../test/webview_flutter_test.dart            | 1260 -----------------
 45 files changed, 2262 insertions(+), 1864 deletions(-)
 create mode 100644 packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FileChooseActivity.java
 delete mode 100644 packages/webview_flutter/example/android/app/src/androidTestDebug/java/io/flutter/plugins/webviewflutterexample/EmbeddingV1ActivityTest.java
 create mode 100644 packages/webview_flutter/example/android/app/src/main/java/io/flutter/plugins/webviewflutterexample/MainActivity.java
 create mode 100644 packages/webview_flutter/example/android/app/src/main/java/io/flutter/plugins/webviewflutterexample/MainApplication.java
 create mode 100644 packages/webview_flutter/example/android/app/src/main/res/xml/network_security_config.xml
 create mode 100644 packages/webview_flutter/example/android/app/src/main/res/xml/provider_paths.xml
 create mode 100644 packages/webview_flutter/example/lib/main1.dart
 create mode 100644 packages/webview_flutter/example/lib/testWeb.dart
 create mode 100644 packages/webview_flutter/ios/Classes/FLTGestureInterceptView.h
 create mode 100644 packages/webview_flutter/ios/Classes/FLTGestureInterceptView.m
 create mode 100644 packages/webview_flutter/ios/Tests/FLTWebViewTests.m
 delete mode 100644 packages/webview_flutter/test/webview_flutter_test.dart

diff --git a/packages/webview_flutter/android/build.gradle b/packages/webview_flutter/android/build.gradle
index 45f769b4b..695e4ac94 100644
--- a/packages/webview_flutter/android/build.gradle
+++ b/packages/webview_flutter/android/build.gradle
@@ -4,11 +4,12 @@ version '1.0-SNAPSHOT'
 buildscript {
     repositories {
         google()
-        mavenCentral()
+        jcenter()
+//        mavenCentral()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.3.0'
+        classpath 'com.android.tools.build:gradle:4.0.2'
     }
 }
 
diff --git a/packages/webview_flutter/android/src/main/AndroidManifest.xml b/packages/webview_flutter/android/src/main/AndroidManifest.xml
index a087f2c75..1dc09b150 100644
--- a/packages/webview_flutter/android/src/main/AndroidManifest.xml
+++ b/packages/webview_flutter/android/src/main/AndroidManifest.xml
@@ -1,2 +1,11 @@
-<manifest package="io.flutter.plugins.webviewflutter">
+<manifest package="io.flutter.plugins.webviewflutter"
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools">
+
+    <application>
+        <activity
+            android:name="io.flutter.plugins.webviewflutter.FileChooseActivity"
+            android:theme="@android:style/Theme.Translucent.NoTitleBar"/>
+    </application>
+
 </manifest>
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/DisplayListenerProxy.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/DisplayListenerProxy.java
index 31e3fe08c..1273e7349 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/DisplayListenerProxy.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/DisplayListenerProxy.java
@@ -1,7 +1,3 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
 package io.flutter.plugins.webviewflutter;
 
 import static android.hardware.display.DisplayManager.DisplayListener;
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FileChooseActivity.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FileChooseActivity.java
new file mode 100644
index 000000000..dcac539ca
--- /dev/null
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FileChooseActivity.java
@@ -0,0 +1,93 @@
+package io.flutter.plugins.webviewflutter;
+
+import android.app.Activity;
+import android.content.ClipData;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.view.WindowManager;
+import android.webkit.ValueCallback;
+import android.webkit.WebChromeClient;
+
+import androidx.annotation.Nullable;
+
+import java.io.File;
+
+public class FileChooseActivity extends Activity {
+  private static ValueCallback<Uri[]> sUploadMessages;
+  private static WebChromeClient.FileChooserParams sFileChooserParams;
+  private Object Utils;
+  private File outputFile;
+  private Uri mOutputFileUri;
+  private Uri image;
+
+  public static void setFilePathCallback(ValueCallback<Uri[]> filePathCallback){
+    sUploadMessages = filePathCallback;
+  }
+
+  public static void setFileChooserParams(WebChromeClient.FileChooserParams fileChooserParams){
+    sFileChooserParams = fileChooserParams;
+  }
+
+  @Override
+  protected void onCreate(@Nullable Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
+
+    openFileIntent();
+  }
+
+
+  private Uri outputFileUri;
+
+  private void openFileIntent() {
+    Intent intent;
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
+      intent = new Intent(Intent.ACTION_GET_CONTENT);
+    } else {
+      intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
+      intent.addCategory(Intent.CATEGORY_OPENABLE);
+    }
+    intent.setType("*/*");
+    try {
+      startActivityForResult(intent, 42);
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+
+  @Override
+  protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
+    super.onActivityResult(requestCode, resultCode, intent);
+    Uri[] results = null;
+    try {
+      if (resultCode != RESULT_OK) {
+        results = null;
+      } else {
+        if (intent != null) {
+          String dataString = intent.getDataString();
+          ClipData clipData = intent.getClipData();
+          if (clipData != null) {
+            results = new Uri[clipData.getItemCount()];
+            for (int i = 0; i < clipData.getItemCount(); i++) {
+              ClipData.Item item = clipData.getItemAt(i);
+              results[i] = item.getUri();
+            }
+          }
+          if (dataString != null) {
+            results = new Uri[]{Uri.parse(dataString)};
+          }
+        } else {
+          results = new Uri[]{mOutputFileUri};
+        }
+      }
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+    if (sUploadMessages != null) sUploadMessages.onReceiveValue(results);
+    sUploadMessages = null;
+    finish();
+  }
+}
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterCookieManager.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterCookieManager.java
index df3f21daa..86b4fd412 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterCookieManager.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterCookieManager.java
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterWebView.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterWebView.java
index ebc7c3198..f742c0ec0 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterWebView.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterWebView.java
@@ -1,18 +1,29 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2018 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
 package io.flutter.plugins.webviewflutter;
 
 import android.annotation.TargetApi;
+import android.app.Activity;
 import android.content.Context;
+import android.content.Intent;
+import android.graphics.Color;
+import android.graphics.Outline;
+import android.graphics.drawable.GradientDrawable;
 import android.hardware.display.DisplayManager;
+import android.net.Uri;
 import android.os.Build;
 import android.os.Handler;
 import android.os.Message;
+import android.text.TextUtils;
 import android.view.View;
+import android.view.ViewOutlineProvider;
+import android.webkit.DownloadListener;
+import android.webkit.GeolocationPermissions;
+import android.webkit.ValueCallback;
 import android.webkit.WebChromeClient;
-import android.webkit.WebResourceRequest;
+import android.webkit.WebSettings;
 import android.webkit.WebStorage;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
@@ -22,46 +33,50 @@ import io.flutter.plugin.common.MethodCall;
 import io.flutter.plugin.common.MethodChannel;
 import io.flutter.plugin.common.MethodChannel.MethodCallHandler;
 import io.flutter.plugin.common.MethodChannel.Result;
+import io.flutter.plugin.common.PluginRegistry;
 import io.flutter.plugin.platform.PlatformView;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
+import android.webkit.WebResourceRequest;
 
 public class FlutterWebView implements PlatformView, MethodCallHandler {
   private static final String JS_CHANNEL_NAMES_FIELD = "javascriptChannelNames";
   private final WebView webView;
   private final MethodChannel methodChannel;
-  private final FlutterWebViewClient flutterWebViewClient;
+  private FlutterWebViewClient flutterWebViewClient;
   private final Handler platformThreadHandler;
+  private Map<String, String> httpHeaders;
 
   // Verifies that a url opened by `Window.open` has a secure url.
   private class FlutterWebChromeClient extends WebChromeClient {
     @Override
     public boolean onCreateWindow(
-        final WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) {
+            final WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) {
       final WebViewClient webViewClient =
-          new WebViewClient() {
-            @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-            @Override
-            public boolean shouldOverrideUrlLoading(
-                @NonNull WebView view, @NonNull WebResourceRequest request) {
-              final String url = request.getUrl().toString();
-              if (!flutterWebViewClient.shouldOverrideUrlLoading(
-                  FlutterWebView.this.webView, request)) {
-                webView.loadUrl(url);
-              }
-              return true;
-            }
-
-            @Override
-            public boolean shouldOverrideUrlLoading(WebView view, String url) {
-              if (!flutterWebViewClient.shouldOverrideUrlLoading(
-                  FlutterWebView.this.webView, url)) {
-                webView.loadUrl(url);
-              }
-              return true;
-            }
-          };
+              new WebViewClient() {
+                @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+                @Override
+                public boolean shouldOverrideUrlLoading(
+                        @NonNull WebView view, @NonNull WebResourceRequest request) {
+                  final String url = request.getUrl().toString();
+                  if (!flutterWebViewClient.shouldOverrideUrlLoading(
+                          FlutterWebView.this.webView, request)) {
+                    webView.loadUrl(url);
+                  }
+                  return true;
+                }
+
+                @Override
+                public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                  if (!flutterWebViewClient.shouldOverrideUrlLoading(
+                          FlutterWebView.this.webView, url)) {
+                    webView.loadUrl(url);
+                  }
+                  return true;
+                }
+              };
 
       final WebView newWebView = new WebView(view.getContext());
       newWebView.setWebViewClient(webViewClient);
@@ -82,22 +97,23 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   @SuppressWarnings("unchecked")
   FlutterWebView(
-      final Context context,
-      BinaryMessenger messenger,
-      int id,
-      Map<String, Object> params,
-      View containerView) {
+          final Context context,
+          PluginRegistry.Registrar registrar,
+          ActivityPluginBinding activityPluginBinding,
+          BinaryMessenger messenger,
+          int id,
+          Map<String, Object> params,
+          View containerView) {
 
     DisplayListenerProxy displayListenerProxy = new DisplayListenerProxy();
     DisplayManager displayManager =
-        (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
+            (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
     displayListenerProxy.onPreWebViewInitialization(displayManager);
-
     Boolean usesHybridComposition = (Boolean) params.get("usesHybridComposition");
     webView =
-        (usesHybridComposition)
-            ? new WebView(context)
-            : new InputAwareWebView(context, containerView);
+            (usesHybridComposition)
+                    ? new WebView(context)
+                    : new InputAwareWebView(context, containerView);
 
     displayListenerProxy.onPostWebViewInitialization(displayManager);
 
@@ -105,22 +121,59 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
     // Allow local storage.
     webView.getSettings().setDomStorageEnabled(true);
     webView.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);
-
-    // Multi windows is set with FlutterWebChromeClient by default to handle internal bug: b/159892679.
+    webView.getSettings().setJavaScriptEnabled(true);
+    webView.getSettings().setPluginState(WebSettings.PluginState.ON);
+    webView.getSettings().setAllowFileAccess(true);
+    webView.getSettings().setAllowContentAccess(true);
+    webView.getSettings().setAllowFileAccessFromFileURLs(true);
+    webView.getSettings().setAllowUniversalAccessFromFileURLs(true);
     webView.getSettings().setSupportMultipleWindows(true);
-    webView.setWebChromeClient(new FlutterWebChromeClient());
+
+    //启用地理定位
+    webView.getSettings().setGeolocationEnabled(true);
+    //fix升级flutter 1.12之后Android上默认滚动条在左(原因不明)
+    webView.setVerticalScrollbarPosition(View.SCROLLBAR_POSITION_RIGHT);
+    // 支持微信公众号文章中视频播放
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+      webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);
+    }
+
+    //支持下载
+    webView.setDownloadListener(new DownloadListener() {
+      @Override
+      public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimeType, long contentLength) {
+        downloadByBrowser(context, url);
+      }
+    });
 
     methodChannel = new MethodChannel(messenger, "plugins.flutter.io/webview_" + id);
     methodChannel.setMethodCallHandler(this);
 
-    flutterWebViewClient = new FlutterWebViewClient(methodChannel);
-    Map<String, Object> settings = (Map<String, Object>) params.get("settings");
-    if (settings != null) applySettings(settings);
+    if(registrar != null){
+      flutterWebViewClient = new FlutterWebViewClient(registrar,methodChannel);
+    }else if(activityPluginBinding != null){
+      flutterWebViewClient = new FlutterWebViewClient(activityPluginBinding,methodChannel);
+    }
+
+    final WebViewClient webViewClient =
+            flutterWebViewClient.createWebViewClient(false);
+    webView.setWebViewClient(webViewClient);
+
+    boolean useAndroidDefaultChromeClient = false;
+    if (params.containsKey("useAndroidDefaultChromeClient")) {
+      useAndroidDefaultChromeClient = (boolean) params.get("useAndroidDefaultChromeClient");
+    }
+    final WebChromeClient webChromeClient =
+            flutterWebViewClient.createWebChromeClient(context, useAndroidDefaultChromeClient);
+    webView.setWebChromeClient(webChromeClient);
+
+    applySettings((Map<String, Object>) params.get("settings"));
 
     if (params.containsKey(JS_CHANNEL_NAMES_FIELD)) {
       List<String> names = (List<String>) params.get(JS_CHANNEL_NAMES_FIELD);
       if (names != null) registerJavaScriptChannelNames(names);
     }
+    flutterWebViewClient.setHeaders(httpHeaders);
 
     Integer autoMediaPlaybackPolicy = (Integer) params.get("autoMediaPlaybackPolicy");
     if (autoMediaPlaybackPolicy != null) updateAutoMediaPlaybackPolicy(autoMediaPlaybackPolicy);
@@ -130,8 +183,47 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
     }
     if (params.containsKey("initialUrl")) {
       String url = (String) params.get("initialUrl");
-      webView.loadUrl(url);
+      if(httpHeaders != null && httpHeaders.size() > 0){
+        webView.loadUrl(url,httpHeaders);
+      }else {
+        webView.loadUrl(url);
+      }
+    }
+
+    if (params.containsKey("androidCornerRadius")) {
+      double cornerRadius = (double) params.get("androidCornerRadius");
+      setCornerRadius(new Double(cornerRadius).floatValue());
     }
+
+    if (params.containsKey("backgroundColor")) {
+      Object backgroundColor = params.get("backgroundColor");
+      if (backgroundColor instanceof Number) {
+        webView.setBackgroundColor(((Number) backgroundColor).intValue());
+      }
+    }
+  }
+
+  private  void setCornerRadius(final float radius) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+      webView.setOutlineProvider(new ViewOutlineProvider() {
+        @Override
+        public void getOutline(View view, Outline outline) {
+          outline.setRoundRect(
+                  0, 0, view.getRight(), view.getBottom(),
+                  radius * webView.getResources().getDisplayMetrics().density
+          );
+        }
+      });
+      webView.setClipToOutline(true);
+    }
+  }
+
+  private void downloadByBrowser(Context context, String url) {
+    Intent intent = new Intent(Intent.ACTION_VIEW);
+    intent.addCategory(Intent.CATEGORY_BROWSABLE);
+    intent.setData(Uri.parse(url));
+    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+    context.getApplicationContext().startActivity(intent);
   }
 
   @Override
@@ -302,13 +394,13 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
       throw new UnsupportedOperationException("JavaScript string cannot be null");
     }
     webView.evaluateJavascript(
-        jsString,
-        new android.webkit.ValueCallback<String>() {
-          @Override
-          public void onReceiveValue(String value) {
-            result.success(value);
-          }
-        });
+            jsString,
+            new android.webkit.ValueCallback<String>() {
+              @Override
+              public void onReceiveValue(String value) {
+                result.success(value);
+              }
+            });
   }
 
   @SuppressWarnings("unchecked")
@@ -338,7 +430,7 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
   }
 
   private void scrollTo(MethodCall methodCall, Result result) {
-    Map<String, Object> request = methodCall.arguments();
+    Map<String, Object> request = (Map<String, Object>) methodCall.arguments;
     int x = (int) request.get("x");
     int y = (int) request.get("y");
 
@@ -348,7 +440,7 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
   }
 
   private void scrollBy(MethodCall methodCall, Result result) {
-    Map<String, Object> request = methodCall.arguments();
+    Map<String, Object> request = (Map<String, Object>) methodCall.arguments;
     int x = (int) request.get("x");
     int y = (int) request.get("y");
 
@@ -375,13 +467,12 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
           final boolean hasNavigationDelegate = (boolean) settings.get(key);
 
           final WebViewClient webViewClient =
-              flutterWebViewClient.createWebViewClient(hasNavigationDelegate);
+                  flutterWebViewClient.createWebViewClient(hasNavigationDelegate);
 
           webView.setWebViewClient(webViewClient);
           break;
         case "debuggingEnabled":
           final boolean debuggingEnabled = (boolean) settings.get(key);
-
           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
             webView.setWebContentsDebuggingEnabled(debuggingEnabled);
           }
@@ -397,6 +488,18 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
         case "allowsInlineMediaPlayback":
           // no-op inline media playback is always allowed on Android.
           break;
+        case "headers":
+          Object obj = settings.get(key);
+          android.util.Log.i("FlutterWebViewClient", "settings==>"+settings.toString());
+          if(obj != null ){
+            httpHeaders = (Map<String, String>) obj;
+            android.util.Log.i("FlutterWebViewClient", "httpHeaders==>"+httpHeaders.toString());
+          }
+          break;
+        case "supportZoom":
+          boolean supportZoom = (boolean) settings.get(key);
+          webView.getSettings().setSupportZoom(supportZoom);
+          break;
         default:
           throw new IllegalArgumentException("Unknown WebView setting: " + key);
       }
@@ -428,7 +531,7 @@ public class FlutterWebView implements PlatformView, MethodCallHandler {
   private void registerJavaScriptChannelNames(List<String> channelNames) {
     for (String channelName : channelNames) {
       webView.addJavascriptInterface(
-          new JavaScriptChannel(methodChannel, channelName, platformThreadHandler), channelName);
+              new JavaScriptChannel(methodChannel, channelName, platformThreadHandler), channelName);
     }
   }
 
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterWebViewClient.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterWebViewClient.java
index 4e7056f14..0fc557d9f 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterWebViewClient.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/FlutterWebViewClient.java
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -6,295 +6,564 @@ package io.flutter.plugins.webviewflutter;
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.content.Context;
 import android.graphics.Bitmap;
+import android.app.Activity;
+import android.content.Intent;
+import android.net.Uri;
+import android.net.http.SslError;
 import android.os.Build;
+import android.os.Message;
 import android.util.Log;
 import android.view.KeyEvent;
+import android.webkit.GeolocationPermissions;
+import android.webkit.SslErrorHandler;
+import android.webkit.ValueCallback;
+import android.webkit.WebChromeClient;
 import android.webkit.WebResourceError;
 import android.webkit.WebResourceRequest;
+import android.webkit.WebResourceResponse;
+import androidx.webkit.WebResourceErrorCompat;
+import androidx.annotation.RequiresApi;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
-import androidx.annotation.RequiresApi;
-import androidx.webkit.WebResourceErrorCompat;
+import android.view.View;
+import android.widget.FrameLayout;
+
+import androidx.annotation.NonNull;
 import androidx.webkit.WebViewClientCompat;
+
 import io.flutter.plugin.common.MethodChannel;
+import io.flutter.plugin.common.PluginRegistry;
+
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 
+import static android.app.Activity.RESULT_OK;
+import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
+
 // We need to use WebViewClientCompat to get
 // shouldOverrideUrlLoading(WebView view, WebResourceRequest request)
 // invoked by the webview on older Android devices, without it pages that use iframes will
 // be broken when a navigationDelegate is set on Android version earlier than N.
-class FlutterWebViewClient {
-  private static final String TAG = "FlutterWebViewClient";
-  private final MethodChannel methodChannel;
-  private boolean hasNavigationDelegate;
-  boolean hasProgressTracking;
-
-  FlutterWebViewClient(MethodChannel methodChannel) {
-    this.methodChannel = methodChannel;
-  }
-
-  static String errorCodeToString(int errorCode) {
-    switch (errorCode) {
-      case WebViewClient.ERROR_AUTHENTICATION:
-        return "authentication";
-      case WebViewClient.ERROR_BAD_URL:
-        return "badUrl";
-      case WebViewClient.ERROR_CONNECT:
-        return "connect";
-      case WebViewClient.ERROR_FAILED_SSL_HANDSHAKE:
-        return "failedSslHandshake";
-      case WebViewClient.ERROR_FILE:
-        return "file";
-      case WebViewClient.ERROR_FILE_NOT_FOUND:
-        return "fileNotFound";
-      case WebViewClient.ERROR_HOST_LOOKUP:
-        return "hostLookup";
-      case WebViewClient.ERROR_IO:
-        return "io";
-      case WebViewClient.ERROR_PROXY_AUTHENTICATION:
-        return "proxyAuthentication";
-      case WebViewClient.ERROR_REDIRECT_LOOP:
-        return "redirectLoop";
-      case WebViewClient.ERROR_TIMEOUT:
-        return "timeout";
-      case WebViewClient.ERROR_TOO_MANY_REQUESTS:
-        return "tooManyRequests";
-      case WebViewClient.ERROR_UNKNOWN:
-        return "unknown";
-      case WebViewClient.ERROR_UNSAFE_RESOURCE:
-        return "unsafeResource";
-      case WebViewClient.ERROR_UNSUPPORTED_AUTH_SCHEME:
-        return "unsupportedAuthScheme";
-      case WebViewClient.ERROR_UNSUPPORTED_SCHEME:
-        return "unsupportedScheme";
+class FlutterWebViewClient implements PluginRegistry.ActivityResultListener {
+    private static final String TAG = "FlutterWebViewClient";
+    private final MethodChannel methodChannel;
+    private boolean hasNavigationDelegate;
+    boolean hasProgressTracking;
+    private static final String BRIDGE_NAME = "Bridge";
+    private boolean mLastLoadFailed = false;
+    private final Activity activity;
+
+    private ValueCallback<Uri> mUploadMessage;
+    private ValueCallback<Uri[]> mUploadMessageArray;
+    private final static int FILECHOOSER_RESULTCODE = 1;
+    private Map<String, String> httpHeaders;
+
+    FlutterWebViewClient(PluginRegistry.Registrar registrar, MethodChannel methodChannel) {
+        this.methodChannel = methodChannel;
+        this.activity = registrar.activity();
+        registrar.addActivityResultListener(this);
     }
 
-    final String message =
-        String.format(Locale.getDefault(), "Could not find a string for errorCode: %d", errorCode);
-    throw new IllegalArgumentException(message);
-  }
+    FlutterWebViewClient(ActivityPluginBinding activityPluginBinding, MethodChannel methodChannel) {
+        this.methodChannel = methodChannel;
+        this.activity = activityPluginBinding.getActivity();
+        activityPluginBinding.addActivityResultListener(this);
+    }
 
-  @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-  boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
-    if (!hasNavigationDelegate) {
-      return false;
+    static String errorCodeToString(int errorCode) {
+        switch (errorCode) {
+            case WebViewClient.ERROR_AUTHENTICATION:
+                return "authentication";
+            case WebViewClient.ERROR_BAD_URL:
+                return "badUrl";
+            case WebViewClient.ERROR_CONNECT:
+                return "connect";
+            case WebViewClient.ERROR_FAILED_SSL_HANDSHAKE:
+                return "failedSslHandshake";
+            case WebViewClient.ERROR_FILE:
+                return "file";
+            case WebViewClient.ERROR_FILE_NOT_FOUND:
+                return "fileNotFound";
+            case WebViewClient.ERROR_HOST_LOOKUP:
+                return "hostLookup";
+            case WebViewClient.ERROR_IO:
+                return "io";
+            case WebViewClient.ERROR_PROXY_AUTHENTICATION:
+                return "proxyAuthentication";
+            case WebViewClient.ERROR_REDIRECT_LOOP:
+                return "redirectLoop";
+            case WebViewClient.ERROR_TIMEOUT:
+                return "timeout";
+            case WebViewClient.ERROR_TOO_MANY_REQUESTS:
+                return "tooManyRequests";
+            case WebViewClient.ERROR_UNKNOWN:
+                return "unknown";
+            case WebViewClient.ERROR_UNSAFE_RESOURCE:
+                return "unsafeResource";
+            case WebViewClient.ERROR_UNSUPPORTED_AUTH_SCHEME:
+                return "unsupportedAuthScheme";
+            case WebViewClient.ERROR_UNSUPPORTED_SCHEME:
+                return "unsupportedScheme";
+        }
+
+        final String message =
+                String.format(Locale.getDefault(), "Could not find a string for errorCode: %d", errorCode);
+        throw new IllegalArgumentException(message);
     }
-    notifyOnNavigationRequest(
-        request.getUrl().toString(), request.getRequestHeaders(), view, request.isForMainFrame());
-    // We must make a synchronous decision here whether to allow the navigation or not,
-    // if the Dart code has set a navigation delegate we want that delegate to decide whether
-    // to navigate or not, and as we cannot get a response from the Dart delegate synchronously we
-    // return true here to block the navigation, if the Dart delegate decides to allow the
-    // navigation the plugin will later make an addition loadUrl call for this url.
-    //
-    // Since we cannot call loadUrl for a subframe, we currently only allow the delegate to stop
-    // navigations that target the main frame, if the request is not for the main frame
-    // we just return false to allow the navigation.
-    //
-    // For more details see: https://github.com/flutter/flutter/issues/25329#issuecomment-464863209
-    return request.isForMainFrame();
-  }
-
-  boolean shouldOverrideUrlLoading(WebView view, String url) {
-    if (!hasNavigationDelegate) {
-      return false;
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
+        if (!hasNavigationDelegate) {
+            return false;
+        }
+        if (request != null) {
+            android.util.Log.i(TAG, "shouldOverrideUrlLoading: headers==>" + request.toString());
+
+            try {
+                String url = request.getUrl().toString();
+                if(url.startsWith("weixin://dl/business") //微信
+//                  || url.startsWith("alipays://") //支付宝
+//                  || url.startsWith("mailto://") //邮件
+//                  || url.startsWith("tel://")//电话
+//                  || url.startsWith("dianping://")//大众点评
+                    //其他自定义的scheme
+                ) {
+                    Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    view.getContext().startActivity(intent);
+                    return true;
+                }
+            } catch (Exception e) { //防止crash (如果手机上没有安装处理某个scheme开头的url的APP, 会导致crash)
+                return true;//没有安装该app时，返回true，表示拦截自定义链接，但不跳转，避免弹出上面的错误页面
+            }
+        }
+        notifyOnNavigationRequest(
+                request.getUrl().toString(), request.getRequestHeaders(), view, request.isForMainFrame());
+        // We must make a synchronous decision here whether to allow the navigation or not,
+        // if the Dart code has set a navigation delegate we want that delegate to decide whether
+        // to navigate or not, and as we cannot get a response from the Dart delegate synchronously we
+        // return true here to block the navigation, if the Dart delegate decides to allow the
+        // navigation the plugin will later make an addition loadUrl call for this url.
+        //
+        // Since we cannot call loadUrl for a subframe, we currently only allow the delegate to stop
+        // navigations that target the main frame, if the request is not for the main frame
+        // we just return false to allow the navigation.
+        //
+        // For more details see: https://github.com/flutter/flutter/issues/25329#issuecomment-464863209
+        return request.isForMainFrame();
     }
-    // This version of shouldOverrideUrlLoading is only invoked by the webview on devices with
-    // webview versions  earlier than 67(it is also invoked when hasNavigationDelegate is false).
-    // On these devices we cannot tell whether the navigation is targeted to the main frame or not.
-    // We proceed assuming that the navigation is targeted to the main frame. If the page had any
-    // frames they will be loaded in the main frame instead.
-    Log.w(
-        TAG,
-        "Using a navigationDelegate with an old webview implementation, pages with frames or iframes will not work");
-    notifyOnNavigationRequest(url, null, view, true);
-    return true;
-  }
-
-  private void onPageStarted(WebView view, String url) {
-    Map<String, Object> args = new HashMap<>();
-    args.put("url", url);
-    methodChannel.invokeMethod("onPageStarted", args);
-  }
-
-  private void onPageFinished(WebView view, String url) {
-    Map<String, Object> args = new HashMap<>();
-    args.put("url", url);
-    methodChannel.invokeMethod("onPageFinished", args);
-  }
-
-  void onLoadingProgress(int progress) {
-    if (hasProgressTracking) {
-      Map<String, Object> args = new HashMap<>();
-      args.put("progress", progress);
-      methodChannel.invokeMethod("onProgress", args);
+
+    boolean shouldOverrideUrlLoading(WebView view, String url) {
+        if (!hasNavigationDelegate) {
+            return false;
+        }
+        if(url != null) {
+            android.util.Log.i(TAG, "shouldOverrideUrlLoading: headers==>" + url);
+            try {
+                if(url.startsWith("weixin://dl/business") //微信
+//                  || url.startsWith("alipays://") //支付宝
+//                  || url.startsWith("mailto://") //邮件
+//                  || url.startsWith("tel://")//电话
+//                  || url.startsWith("dianping://")//大众点评
+                    //其他自定义的scheme
+                ) {
+                    Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    view.getContext().startActivity(intent);
+                    return true;
+                }
+            } catch (Exception e) { //防止crash (如果手机上没有安装处理某个scheme开头的url的APP, 会导致crash)
+                return true;//没有安装该app时，返回true，表示拦截自定义链接，但不跳转，避免弹出上面的错误页面
+            }
+        }
+
+        // This version of shouldOverrideUrlLoading is only invoked by the webview on devices with
+        // webview versions  earlier than 67(it is also invoked when hasNavigationDelegate is false).
+        // On these devices we cannot tell whether the navigation is targeted to the main frame or not.
+        // We proceed assuming that the navigation is targeted to the main frame. If the page had any
+        // frames they will be loaded in the main frame instead.
+        Log.w(
+                TAG,
+                "Using a navigationDelegate with an old webview implementation, pages with frames or iframes will not work");
+        notifyOnNavigationRequest(url, null, view, true);
+        return true;
     }
-  }
-
-  private void onWebResourceError(
-      final int errorCode, final String description, final String failingUrl) {
-    final Map<String, Object> args = new HashMap<>();
-    args.put("errorCode", errorCode);
-    args.put("description", description);
-    args.put("errorType", FlutterWebViewClient.errorCodeToString(errorCode));
-    args.put("failingUrl", failingUrl);
-    methodChannel.invokeMethod("onWebResourceError", args);
-  }
-
-  private void notifyOnNavigationRequest(
-      String url, Map<String, String> headers, WebView webview, boolean isMainFrame) {
-    HashMap<String, Object> args = new HashMap<>();
-    args.put("url", url);
-    args.put("isForMainFrame", isMainFrame);
-    if (isMainFrame) {
-      methodChannel.invokeMethod(
-          "navigationRequest", args, new OnNavigationRequestResult(url, headers, webview));
-    } else {
-      methodChannel.invokeMethod("navigationRequest", args);
+
+    private void injectBridge(WebView view) {
+        view.loadUrl("javascript:(" +
+                "window.originalPostMessage = window.postMessage," +
+                "window.postMessage = function(data) {" +
+                BRIDGE_NAME + ".postMessage(JSON.stringify(data));" +
+                "}" +
+                ")");
     }
-  }
 
-  // This method attempts to avoid using WebViewClientCompat due to bug
-  // https://bugs.chromium.org/p/chromium/issues/detail?id=925887. Also, see
-  // https://github.com/flutter/flutter/issues/29446.
-  WebViewClient createWebViewClient(boolean hasNavigationDelegate) {
-    this.hasNavigationDelegate = hasNavigationDelegate;
+    private void onPageStarted(WebView view, String url) {
+        mLastLoadFailed = false;
+        Map<String, Object> args = new HashMap<>();
+        args.put("url", url);
+        methodChannel.invokeMethod("onPageStarted", args);
+    }
 
-    if (!hasNavigationDelegate || android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
-      return internalCreateWebViewClient();
+    private void onReceivedHttpError(WebView view, WebResourceRequest request, WebResourceResponse errorResponse) {
+        HashMap<String, String> args = new HashMap<>();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            args.put("code", String.valueOf(errorResponse.getStatusCode()));
+            args.put("message", errorResponse.getReasonPhrase());
+            args.put("url", request.getUrl().toString());
+        }
+        methodChannel.invokeMethod("httpError", args);
     }
 
-    return internalCreateWebViewClientCompat();
-  }
-
-  private WebViewClient internalCreateWebViewClient() {
-    return new WebViewClient() {
-      @TargetApi(Build.VERSION_CODES.N)
-      @Override
-      public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
-        return FlutterWebViewClient.this.shouldOverrideUrlLoading(view, request);
-      }
-
-      @Override
-      public void onPageStarted(WebView view, String url, Bitmap favicon) {
-        FlutterWebViewClient.this.onPageStarted(view, url);
-      }
-
-      @Override
-      public void onPageFinished(WebView view, String url) {
-        FlutterWebViewClient.this.onPageFinished(view, url);
-      }
-
-      @TargetApi(Build.VERSION_CODES.M)
-      @Override
-      public void onReceivedError(
-          WebView view, WebResourceRequest request, WebResourceError error) {
-        FlutterWebViewClient.this.onWebResourceError(
-            error.getErrorCode(), error.getDescription().toString(), request.getUrl().toString());
-      }
-
-      @Override
-      public void onReceivedError(
-          WebView view, int errorCode, String description, String failingUrl) {
-        FlutterWebViewClient.this.onWebResourceError(errorCode, description, failingUrl);
-      }
-
-      @Override
-      public void onUnhandledKeyEvent(WebView view, KeyEvent event) {
-        // Deliberately empty. Occasionally the webview will mark events as having failed to be
-        // handled even though they were handled. We don't want to propagate those as they're not
-        // truly lost.
-      }
-    };
-  }
-
-  private WebViewClientCompat internalCreateWebViewClientCompat() {
-    return new WebViewClientCompat() {
-      @Override
-      public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
-        return FlutterWebViewClient.this.shouldOverrideUrlLoading(view, request);
-      }
-
-      @Override
-      public boolean shouldOverrideUrlLoading(WebView view, String url) {
-        return FlutterWebViewClient.this.shouldOverrideUrlLoading(view, url);
-      }
-
-      @Override
-      public void onPageStarted(WebView view, String url, Bitmap favicon) {
-        FlutterWebViewClient.this.onPageStarted(view, url);
-      }
-
-      @Override
-      public void onPageFinished(WebView view, String url) {
-        FlutterWebViewClient.this.onPageFinished(view, url);
-      }
-
-      // This method is only called when the WebViewFeature.RECEIVE_WEB_RESOURCE_ERROR feature is
-      // enabled. The deprecated method is called when a device doesn't support this.
-      @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
-      @SuppressLint("RequiresFeature")
-      @Override
-      public void onReceivedError(
-          WebView view, WebResourceRequest request, WebResourceErrorCompat error) {
-        FlutterWebViewClient.this.onWebResourceError(
-            error.getErrorCode(), error.getDescription().toString(), request.getUrl().toString());
-      }
-
-      @Override
-      public void onReceivedError(
-          WebView view, int errorCode, String description, String failingUrl) {
-        FlutterWebViewClient.this.onWebResourceError(errorCode, description, failingUrl);
-      }
-
-      @Override
-      public void onUnhandledKeyEvent(WebView view, KeyEvent event) {
-        // Deliberately empty. Occasionally the webview will mark events as having failed to be
-        // handled even though they were handled. We don't want to propagate those as they're not
-        // truly lost.
-      }
-    };
-  }
-
-  private static class OnNavigationRequestResult implements MethodChannel.Result {
-    private final String url;
-    private final Map<String, String> headers;
-    private final WebView webView;
-
-    private OnNavigationRequestResult(String url, Map<String, String> headers, WebView webView) {
-      this.url = url;
-      this.headers = headers;
-      this.webView = webView;
+    private void onPageFinished(WebView view, String url) {
+        Map<String, Object> args = new HashMap<>();
+        args.put("url", url);
+        methodChannel.invokeMethod("onPageFinished", args);
+        if (!mLastLoadFailed) {
+            mLastLoadFailed = true;
+            injectBridge(view);
+        }
     }
 
-    @Override
-    public void success(Object shouldLoad) {
-      Boolean typedShouldLoad = (Boolean) shouldLoad;
-      if (typedShouldLoad) {
-        loadUrl();
-      }
+    void onLoadingProgress(int progress) {
+        if (hasProgressTracking) {
+            Map<String, Object> args = new HashMap<>();
+            args.put("progress", progress);
+            methodChannel.invokeMethod("onProgress", args);
+        }
     }
 
-    @Override
-    public void error(String errorCode, String s1, Object o) {
-      throw new IllegalStateException("navigationRequest calls must succeed");
+    private void onWebResourceError(final int errorCode, final String description, final String failingUrl) {
+        final Map<String, Object> args = new HashMap<>();
+        args.put("errorCode", errorCode);
+        args.put("description", description);
+        args.put("errorType", FlutterWebViewClient.errorCodeToString(errorCode));
+        args.put("failingUrl", failingUrl);
+        methodChannel.invokeMethod("onWebResourceError", args);
     }
 
-    @Override
-    public void notImplemented() {
-      throw new IllegalStateException(
-          "navigationRequest must be implemented by the webview method channel");
+    private void notifyOnNavigationRequest(
+            String url, Map<String, String> headers, WebView webview, boolean isMainFrame) {
+        HashMap<String, Object> args = new HashMap<>();
+        args.put("url", url);
+        args.put("isForMainFrame", isMainFrame);
+        if (headers == null && httpHeaders != null) {
+            headers = new HashMap<>();
+            headers.putAll(httpHeaders);
+        }
+        if (isMainFrame) {
+            methodChannel.invokeMethod(
+                    "navigationRequest", args, new OnNavigationRequestResult(url, headers, webview));
+        } else {
+            methodChannel.invokeMethod("navigationRequest", args);
+        }
     }
 
-    private void loadUrl() {
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-        webView.loadUrl(url, headers);
-      } else {
-        webView.loadUrl(url);
-      }
+    // This method attempts to avoid using WebViewClientCompat due to bug
+    // https://bugs.chromium.org/p/chromium/issues/detail?id=925887. Also, see
+    // https://github.com/flutter/flutter/issues/29446.
+    WebViewClient createWebViewClient(boolean hasNavigationDelegate) {
+        this.hasNavigationDelegate = hasNavigationDelegate;
+
+        if (!hasNavigationDelegate || android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            return internalCreateWebViewClient();
+        }
+
+        return internalCreateWebViewClientCompat();
+    }
+
+    private WebViewClient internalCreateWebViewClient() {
+        return new WebViewClient() {
+            @TargetApi(Build.VERSION_CODES.N)
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
+                return FlutterWebViewClient.this.shouldOverrideUrlLoading(view, request);
+            }
+
+            @Override
+            public void onPageStarted(WebView view, String url, Bitmap favicon) {
+                FlutterWebViewClient.this.onPageStarted(view, url);
+            }
+
+            @Override
+            public void onPageFinished(WebView view, String url) {
+                FlutterWebViewClient.this.onPageFinished(view, url);
+            }
+
+            @TargetApi(Build.VERSION_CODES.M)
+            @Override
+            public void onReceivedError(
+                    WebView view, WebResourceRequest request, WebResourceError error) {
+                FlutterWebViewClient.this.onWebResourceError(
+                        error.getErrorCode(), error.getDescription().toString(), request.getUrl().toString());
+            }
+
+            @Override
+            public void onReceivedError(
+                    WebView view, int errorCode, String description, String failingUrl) {
+                FlutterWebViewClient.this.onWebResourceError(errorCode, description, failingUrl);
+            }
+
+            @Override
+            public void onUnhandledKeyEvent(WebView view, KeyEvent event) {
+                // Deliberately empty. Occasionally the webview will mark events as having failed to be
+                // handled even though they were handled. We don't want to propagate those as they're not
+                // truly lost.
+            }
+
+            @Override
+            public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
+                handler.proceed();
+            }
+        };
+    }
+
+    private WebViewClientCompat internalCreateWebViewClientCompat() {
+        return new WebViewClientCompat() {
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
+                return FlutterWebViewClient.this.shouldOverrideUrlLoading(view, request);
+            }
+
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                return FlutterWebViewClient.this.shouldOverrideUrlLoading(view, url);
+            }
+
+            @Override
+            public void onPageStarted(WebView view, String url, Bitmap favicon) {
+                FlutterWebViewClient.this.onPageStarted(view, url);
+            }
+
+            @Override
+            public void onPageFinished(WebView view, String url) {
+                FlutterWebViewClient.this.onPageFinished(view, url);
+            }
+
+            @Override
+            public void onReceivedHttpError(@NonNull WebView view, @NonNull WebResourceRequest request, @NonNull WebResourceResponse errorResponse) {
+                super.onReceivedHttpError(view, request, errorResponse);
+                FlutterWebViewClient.this.onReceivedHttpError(view, request, errorResponse);
+            }
+
+            // This method is only called when the WebViewFeature.RECEIVE_WEB_RESOURCE_ERROR feature is
+            // enabled. The deprecated method is called when a device doesn't support this.
+            @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+            @SuppressLint("RequiresFeature")
+            @Override
+            public void onReceivedError(
+                    WebView view, WebResourceRequest request, WebResourceErrorCompat error) {
+                FlutterWebViewClient.this.onWebResourceError(
+                        error.getErrorCode(), error.getDescription().toString(), request.getUrl().toString());
+            }
+
+            @Override
+            public void onReceivedError(
+                    WebView view, int errorCode, String description, String failingUrl) {
+                FlutterWebViewClient.this.onWebResourceError(errorCode, description, failingUrl);
+            }
+
+            @Override
+            public void onUnhandledKeyEvent(WebView view, KeyEvent event) {
+                // Deliberately empty. Occasionally the webview will mark events as having failed to be
+                // handled even though they were handled. We don't want to propagate those as they're not
+                // truly lost.
+            }
+
+            @Override
+            public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
+                handler.proceed();
+            }
+        };
+    }
+
+    public void setHeaders(Map<String, String> httpHeaders) {
+        this.httpHeaders = httpHeaders;
     }
-  }
+
+    private static class OnNavigationRequestResult implements MethodChannel.Result {
+        private final String url;
+        private final Map<String, String> headers;
+        private final WebView webView;
+
+        private OnNavigationRequestResult(String url, Map<String, String> headers, WebView webView) {
+            this.url = url;
+            this.headers = headers;
+            this.webView = webView;
+        }
+
+        @Override
+        public void success(Object shouldLoad) {
+            Boolean typedShouldLoad = (Boolean) shouldLoad;
+            if (typedShouldLoad) {
+                loadUrl();
+            }
+        }
+
+        @Override
+        public void error(String errorCode, String s1, Object o) {
+            throw new IllegalStateException("navigationRequest calls must succeed");
+        }
+
+        @Override
+        public void notImplemented() {
+            throw new IllegalStateException(
+                    "navigationRequest must be implemented by the webview method channel");
+        }
+
+        private void loadUrl() {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                webView.loadUrl(url, headers);
+            } else {
+                webView.loadUrl(url);
+            }
+        }
+    }
+
+    private View mCustomView;
+    private WebChromeClient.CustomViewCallback mCustomViewCallback;
+    protected FrameLayout mFullscreenContainer;
+    private int mOriginalOrientation;
+    private int mOriginalSystemUiVisibility;
+
+    WebChromeClient createWebChromeClient(final Context context, boolean useDefault) {
+        if (useDefault) return new WebChromeClient();
+        return new WebChromeClient() {
+            @Override
+            public boolean onCreateWindow(
+                    final WebView webView, boolean isDialog, boolean isUserGesture, Message resultMsg) {
+                final WebViewClient webViewClient =
+                        new WebViewClient() {
+                            @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+                            @Override
+                            public boolean shouldOverrideUrlLoading(
+                                    @NonNull WebView view, @NonNull WebResourceRequest request) {
+                                final String url = request.getUrl().toString();
+                                if (!FlutterWebViewClient.this.shouldOverrideUrlLoading(webView, request)) {
+                                    webView.loadUrl(url);
+                                }
+                                return true;
+                            }
+
+                            @Override
+                            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                                if (!FlutterWebViewClient.this.shouldOverrideUrlLoading(webView, url)) {
+                                    webView.loadUrl(url);
+                                }
+                                return true;
+                            }
+                        };
+
+                final WebView newWebView = new WebView(webView.getContext());
+                newWebView.setWebViewClient(webViewClient);
+
+                final WebView.WebViewTransport transport = (WebView.WebViewTransport) resultMsg.obj;
+                transport.setWebView(newWebView);
+                resultMsg.sendToTarget();
+
+                return true;
+            }
+
+            public void onHideCustomView()
+            {
+                ((FrameLayout)activity.getWindow().getDecorView()).removeView(mCustomView);
+                mCustomView = null;
+                activity.getWindow().getDecorView().setSystemUiVisibility(mOriginalSystemUiVisibility);
+                activity.setRequestedOrientation(mOriginalOrientation);
+                mCustomViewCallback.onCustomViewHidden();
+                mCustomViewCallback = null;
+            }
+
+            public void onShowCustomView(View paramView, WebChromeClient.CustomViewCallback paramCustomViewCallback)
+            {
+                if (mCustomView != null)
+                {
+                    onHideCustomView();
+                    return;
+                }
+                mCustomView = paramView;
+                mOriginalSystemUiVisibility = activity.getWindow().getDecorView().getSystemUiVisibility();
+                mOriginalOrientation = activity.getRequestedOrientation();
+                mCustomViewCallback = paramCustomViewCallback;
+                ((FrameLayout)activity.getWindow().getDecorView()).addView(mCustomView, new FrameLayout.LayoutParams(-1, -1));
+                activity.getWindow().getDecorView().setSystemUiVisibility(0x00000400);
+            }
+
+            @Override
+            public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
+                super.onGeolocationPermissionsShowPrompt(origin, callback);
+                callback.invoke(origin, true, false);
+            }
+
+            // For Android 3.0+
+            public void openFileChooser(ValueCallback uploadMsg, String acceptType) {
+                mUploadMessage = uploadMsg;
+                Intent i = new Intent(Intent.ACTION_GET_CONTENT);
+                i.addCategory(Intent.CATEGORY_OPENABLE);
+                i.setType("*/*");
+                activity.startActivityForResult(
+                        Intent.createChooser(i, "File Chooser"),
+                        FILECHOOSER_RESULTCODE);
+            }
+
+            //For Android 4.1
+            public void openFileChooser(ValueCallback<Uri> uploadMsg, String acceptType, String capture) {
+                mUploadMessage = uploadMsg;
+                Intent i = new Intent(Intent.ACTION_GET_CONTENT);
+                i.addCategory(Intent.CATEGORY_OPENABLE);
+                i.setType("image/*");
+                activity.startActivityForResult(Intent.createChooser(i, "File Chooser"), FILECHOOSER_RESULTCODE);
+            }
+
+            @Override
+            public boolean onShowFileChooser(WebView webView, ValueCallback<Uri[]> filePathCallback, FileChooserParams fileChooserParams) {
+              // Successfully jump to newActivity! ! ! Very nice
+              // jump to newActivity to open the folder operation
+              Intent intent = new Intent(context, FileChooseActivity.class );
+              FileChooseActivity.setFilePathCallback(filePathCallback);
+              FileChooseActivity.setFileChooserParams(fileChooserParams);
+              intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+              context.startActivity(intent);
+              return true;
+            }
+        };
+    }
+
+    @Override
+    public boolean onActivityResult(int requestCode, int resultCode, Intent intent) {
+        boolean handled = false;
+        if (Build.VERSION.SDK_INT >= 21) {
+            Uri[] results = null;
+            // check result
+            if (resultCode == Activity.RESULT_OK) {
+                if (requestCode == FILECHOOSER_RESULTCODE) {
+                    if (mUploadMessageArray != null) {
+                        String dataString = intent.getDataString();
+                        if (dataString != null) {
+                            results = new Uri[]{Uri.parse(dataString)};
+                        }
+
+                        mUploadMessageArray.onReceiveValue(results);
+                        mUploadMessageArray = null;
+                    }
+                    handled = true;
+                }
+            }
+        } else {
+            if (requestCode == FILECHOOSER_RESULTCODE) {
+                if (null != mUploadMessage) {
+                    Uri result = intent == null || resultCode != RESULT_OK ? null
+                            : intent.getData();
+                    mUploadMessage.onReceiveValue(result);
+                    mUploadMessage = null;
+                }
+                handled = true;
+            }
+        }
+        return handled;
+    }
+
 }
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/InputAwareWebView.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/InputAwareWebView.java
index 51b2a3809..6d549bc08 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/InputAwareWebView.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/InputAwareWebView.java
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -6,10 +6,12 @@ package io.flutter.plugins.webviewflutter;
 
 import static android.content.Context.INPUT_METHOD_SERVICE;
 
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Rect;
-import android.os.Build;
 import android.util.Log;
+import android.os.Build;
 import android.view.View;
 import android.view.inputmethod.InputMethodManager;
 import android.webkit.WebView;
@@ -34,6 +36,7 @@ final class InputAwareWebView extends WebView {
   InputAwareWebView(Context context, View containerView) {
     super(context);
     this.containerView = containerView;
+    setBackgroundColor(0x00000000);
   }
 
   void setContainerView(View containerView) {
@@ -158,7 +161,7 @@ final class InputAwareWebView extends WebView {
    * <p>{@code targetView} should have a {@link View#getHandler} method with the thread that future
    * InputConnections should be created on.
    */
-  private void setInputConnectionTarget(final View targetView) {
+  void setInputConnectionTarget(final View targetView) {
     if (containerView == null) {
       Log.e(
           TAG,
@@ -171,6 +174,13 @@ final class InputAwareWebView extends WebView {
         new Runnable() {
           @Override
           public void run() {
+            if (containerView == null) {
+              Log.e(
+                  TAG,
+                  "Can't set the input connection target because there is no containerView to use as a handler.");
+              return;
+            }
+
             InputMethodManager imm =
                 (InputMethodManager) getContext().getSystemService(INPUT_METHOD_SERVICE);
             // This is a hack to make InputMethodManager believe that the target view now has focus.
@@ -185,7 +195,11 @@ final class InputAwareWebView extends WebView {
             // onCreateInputConnection() on targetView on the same thread as
             // targetView.getHandler(). It will also call subsequent InputConnection methods on this
             // thread. This is the IME thread in cases where targetView is our proxyAdapterView.
-            imm.isActive(containerView);
+            try{
+              imm.isActive(containerView);
+            } catch (Exception e) {
+              e.printStackTrace();
+            }
           }
         });
   }
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/JavaScriptChannel.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/JavaScriptChannel.java
index 4d596351b..f23aae5b2 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/JavaScriptChannel.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/JavaScriptChannel.java
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/ThreadedInputConnectionProxyAdapterView.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/ThreadedInputConnectionProxyAdapterView.java
index 1c865c944..8fbdfaff1 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/ThreadedInputConnectionProxyAdapterView.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/ThreadedInputConnectionProxyAdapterView.java
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/WebViewFactory.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/WebViewFactory.java
index 22de668e0..f3b03bd0d 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/WebViewFactory.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/WebViewFactory.java
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2018 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -7,25 +7,36 @@ package io.flutter.plugins.webviewflutter;
 import android.content.Context;
 import android.view.View;
 import io.flutter.plugin.common.BinaryMessenger;
+import io.flutter.plugin.common.PluginRegistry;
 import io.flutter.plugin.common.StandardMessageCodec;
 import io.flutter.plugin.platform.PlatformView;
 import io.flutter.plugin.platform.PlatformViewFactory;
 import java.util.Map;
+import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
 
 public final class WebViewFactory extends PlatformViewFactory {
   private final BinaryMessenger messenger;
-  private final View containerView;
+  private  View containerView;
+  private  PluginRegistry.Registrar registrar;
+  private  ActivityPluginBinding activityPluginBinding;
 
-  WebViewFactory(BinaryMessenger messenger, View containerView) {
+  WebViewFactory(PluginRegistry.Registrar registrar, View containerView) {
     super(StandardMessageCodec.INSTANCE);
-    this.messenger = messenger;
+    this.registrar = registrar;
+    this.messenger = registrar.messenger();
     this.containerView = containerView;
   }
 
+  WebViewFactory(ActivityPluginBinding activityPluginBinding, BinaryMessenger messenger) {
+    super(StandardMessageCodec.INSTANCE);
+    this.activityPluginBinding = activityPluginBinding;
+    this.messenger = messenger;
+  }
+
   @SuppressWarnings("unchecked")
   @Override
   public PlatformView create(Context context, int id, Object args) {
     Map<String, Object> params = (Map<String, Object>) args;
-    return new FlutterWebView(context, messenger, id, params, containerView);
+    return new FlutterWebView(context,registrar, activityPluginBinding,messenger, id, params, containerView);
   }
 }
diff --git a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/WebViewFlutterPlugin.java b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/WebViewFlutterPlugin.java
index dc329e227..105067d0b 100644
--- a/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/WebViewFlutterPlugin.java
+++ b/packages/webview_flutter/android/src/main/java/io/flutter/plugins/webviewflutter/WebViewFlutterPlugin.java
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2018 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -6,6 +6,10 @@ package io.flutter.plugins.webviewflutter;
 
 import io.flutter.embedding.engine.plugins.FlutterPlugin;
 import io.flutter.plugin.common.BinaryMessenger;
+import io.flutter.plugin.common.PluginRegistry.Registrar;
+import io.flutter.embedding.engine.plugins.activity.ActivityAware;
+import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
+import androidx.annotation.NonNull;
 
 /**
  * Java platform implementation of the webview_flutter plugin.
@@ -15,9 +19,10 @@ import io.flutter.plugin.common.BinaryMessenger;
  * <p>Call {@link #registerWith(Registrar)} to use the stable {@code io.flutter.plugin.common}
  * package instead.
  */
-public class WebViewFlutterPlugin implements FlutterPlugin {
+public class WebViewFlutterPlugin implements FlutterPlugin, ActivityAware{
 
   private FlutterCookieManager flutterCookieManager;
+  private FlutterPluginBinding flutterBinding;
 
   /**
    * Add an instance of this to {@link io.flutter.embedding.engine.plugins.PluginRegistry} to
@@ -38,7 +43,7 @@ public class WebViewFlutterPlugin implements FlutterPlugin {
    * package.
    *
    * <p>Calling this automatically initializes the plugin. However plugins initialized this way
-   * won't react to changes in activity or context, unlike {@link CameraPlugin}.
+   * won't react to changes in activity or context, unlike .
    */
   @SuppressWarnings("deprecation")
   public static void registerWith(io.flutter.plugin.common.PluginRegistry.Registrar registrar) {
@@ -46,17 +51,18 @@ public class WebViewFlutterPlugin implements FlutterPlugin {
         .platformViewRegistry()
         .registerViewFactory(
             "plugins.flutter.io/webview",
-            new WebViewFactory(registrar.messenger(), registrar.view()));
+            new WebViewFactory(registrar, registrar.view()));
     new FlutterCookieManager(registrar.messenger());
   }
 
   @Override
   public void onAttachedToEngine(FlutterPluginBinding binding) {
+   flutterBinding = binding;
     BinaryMessenger messenger = binding.getBinaryMessenger();
-    binding
-        .getPlatformViewRegistry()
-        .registerViewFactory(
-            "plugins.flutter.io/webview", new WebViewFactory(messenger, /*containerView=*/ null));
+//    binding
+//        .getPlatformViewRegistry()
+//        .registerViewFactory(
+//            "plugins.flutter.io/webview", new WebViewFactory(messenger, /*containerView=*/ null));
     flutterCookieManager = new FlutterCookieManager(messenger);
   }
 
@@ -69,4 +75,30 @@ public class WebViewFlutterPlugin implements FlutterPlugin {
     flutterCookieManager.dispose();
     flutterCookieManager = null;
   }
+
+  @Override
+  public void onAttachedToActivity(@NonNull ActivityPluginBinding binding) {
+    if(flutterBinding == null) return;
+    BinaryMessenger messenger = flutterBinding.getBinaryMessenger();
+    flutterCookieManager = new FlutterCookieManager(messenger);
+    flutterBinding.getPlatformViewRegistry()
+            .registerViewFactory(
+                    "plugins.flutter.io/webview", new WebViewFactory(binding,  messenger));
+  }
+
+  @Override
+  public void onDetachedFromActivityForConfigChanges() {
+
+  }
+
+  @Override
+  public void onReattachedToActivityForConfigChanges(@NonNull ActivityPluginBinding binding) {
+
+  }
+
+  @Override
+  public void onDetachedFromActivity() {
+
+  }
+
 }
diff --git a/packages/webview_flutter/example/android/app/build.gradle b/packages/webview_flutter/example/android/app/build.gradle
index 47eb97623..1031c14fe 100644
--- a/packages/webview_flutter/example/android/app/build.gradle
+++ b/packages/webview_flutter/example/android/app/build.gradle
@@ -25,7 +25,7 @@ apply plugin: 'com.android.application'
 apply from: "$flutterRoot/packages/flutter_tools/gradle/flutter.gradle"
 
 android {
-    compileSdkVersion 29
+    compileSdkVersion 31
 
     lintOptions {
         disable 'InvalidPackage'
@@ -35,7 +35,7 @@ android {
         // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
         applicationId "io.flutter.plugins.webviewflutterexample"
         minSdkVersion 19
-        targetSdkVersion 28
+        targetSdkVersion 29
         versionCode flutterVersionCode.toInteger()
         versionName flutterVersionName
         testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
diff --git a/packages/webview_flutter/example/android/app/gradle/wrapper/gradle-wrapper.properties b/packages/webview_flutter/example/android/app/gradle/wrapper/gradle-wrapper.properties
index 9a4163a4f..e48443d0b 100644
--- a/packages/webview_flutter/example/android/app/gradle/wrapper/gradle-wrapper.properties
+++ b/packages/webview_flutter/example/android/app/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,6 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-6.1.1-all.zip
+
diff --git a/packages/webview_flutter/example/android/app/src/androidTestDebug/java/io/flutter/plugins/webviewflutterexample/EmbeddingV1ActivityTest.java b/packages/webview_flutter/example/android/app/src/androidTestDebug/java/io/flutter/plugins/webviewflutterexample/EmbeddingV1ActivityTest.java
deleted file mode 100644
index 56691d2fc..000000000
--- a/packages/webview_flutter/example/android/app/src/androidTestDebug/java/io/flutter/plugins/webviewflutterexample/EmbeddingV1ActivityTest.java
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-package io.flutter.plugins.webviewflutterexample;
-
-import androidx.test.rule.ActivityTestRule;
-import dev.flutter.plugins.integration_test.FlutterTestRunner;
-import org.junit.Rule;
-import org.junit.runner.RunWith;
-
-@RunWith(FlutterTestRunner.class)
-@SuppressWarnings("deprecation")
-public class EmbeddingV1ActivityTest {
-  @Rule
-  public ActivityTestRule<EmbeddingV1Activity> rule =
-      new ActivityTestRule<>(EmbeddingV1Activity.class);
-}
diff --git a/packages/webview_flutter/example/android/app/src/main/AndroidManifest.xml b/packages/webview_flutter/example/android/app/src/main/AndroidManifest.xml
index 02f270fb9..48b783abc 100644
--- a/packages/webview_flutter/example/android/app/src/main/AndroidManifest.xml
+++ b/packages/webview_flutter/example/android/app/src/main/AndroidManifest.xml
@@ -8,8 +8,10 @@
        FlutterApplication and put your custom class here. -->
   <application
     android:icon="@mipmap/ic_launcher"
+    android:networkSecurityConfig="@xml/network_security_config"
+    android:requestLegacyExternalStorage="true"
     android:label="webview_flutter_example"
-    android:name="io.flutter.app.FlutterApplication">
+    android:name=".MainApplication">
     <meta-data
         android:name="flutterEmbedding"
         android:value="2" />
@@ -17,16 +19,13 @@
       android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
       android:hardwareAccelerated="true"
       android:launchMode="singleTop"
-      android:name="io.flutter.embedding.android.FlutterActivity"
+      android:name=".MainActivity"
       android:theme="@style/LaunchTheme"
       android:windowSoftInputMode="adjustResize">
       <!-- This keeps the window background of the activity showing
            until Flutter renders its first frame. It can be removed if
            there is no splash screen (such as the default splash screen
            defined in @style/LaunchTheme). -->
-      <meta-data
-        android:name="io.flutter.app.android.SplashScreenUntilFirstFrame"
-        android:value="true"/>
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
         <category android:name="android.intent.category.LAUNCHER"/>
diff --git a/packages/webview_flutter/example/android/app/src/main/java/io/flutter/plugins/webviewflutterexample/MainActivity.java b/packages/webview_flutter/example/android/app/src/main/java/io/flutter/plugins/webviewflutterexample/MainActivity.java
new file mode 100644
index 000000000..ede3a0b52
--- /dev/null
+++ b/packages/webview_flutter/example/android/app/src/main/java/io/flutter/plugins/webviewflutterexample/MainActivity.java
@@ -0,0 +1,7 @@
+package io.flutter.plugins.webviewflutterexample;
+
+import io.flutter.embedding.android.FlutterActivity;
+
+public class MainActivity extends FlutterActivity {
+
+}
diff --git a/packages/webview_flutter/example/android/app/src/main/java/io/flutter/plugins/webviewflutterexample/MainApplication.java b/packages/webview_flutter/example/android/app/src/main/java/io/flutter/plugins/webviewflutterexample/MainApplication.java
new file mode 100644
index 000000000..467d6c767
--- /dev/null
+++ b/packages/webview_flutter/example/android/app/src/main/java/io/flutter/plugins/webviewflutterexample/MainApplication.java
@@ -0,0 +1,7 @@
+package io.flutter.plugins.webviewflutterexample;
+
+import android.app.Application;
+
+public class MainApplication extends Application {
+
+}
diff --git a/packages/webview_flutter/example/android/app/src/main/res/xml/network_security_config.xml b/packages/webview_flutter/example/android/app/src/main/res/xml/network_security_config.xml
new file mode 100644
index 000000000..dca93c079
--- /dev/null
+++ b/packages/webview_flutter/example/android/app/src/main/res/xml/network_security_config.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<network-security-config>
+    <base-config cleartextTrafficPermitted="true" />
+</network-security-config>
\ No newline at end of file
diff --git a/packages/webview_flutter/example/android/app/src/main/res/xml/provider_paths.xml b/packages/webview_flutter/example/android/app/src/main/res/xml/provider_paths.xml
new file mode 100644
index 000000000..a1ac63078
--- /dev/null
+++ b/packages/webview_flutter/example/android/app/src/main/res/xml/provider_paths.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<paths xmlns:android="http://schemas.android.com/apk/res/android">
+    <external-path name="external_files" path="."/>
+    <external-files-path name="upgrade_dir" path="upgrade/" />
+</paths>
\ No newline at end of file
diff --git a/packages/webview_flutter/example/android/build.gradle b/packages/webview_flutter/example/android/build.gradle
index e101ac08d..a55d94e46 100644
--- a/packages/webview_flutter/example/android/build.gradle
+++ b/packages/webview_flutter/example/android/build.gradle
@@ -1,11 +1,12 @@
 buildscript {
     repositories {
         google()
-        mavenCentral()
+        jcenter()
+//        mavenCentral()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.3.0'
+        classpath 'com.android.tools.build:gradle:4.0.2'
     }
 }
 
diff --git a/packages/webview_flutter/example/android/gradle/wrapper/gradle-wrapper.properties b/packages/webview_flutter/example/android/gradle/wrapper/gradle-wrapper.properties
index 2819f022f..493072b3c 100644
--- a/packages/webview_flutter/example/android/gradle/wrapper/gradle-wrapper.properties
+++ b/packages/webview_flutter/example/android/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.2-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-6.1.1-all.zip
diff --git a/packages/webview_flutter/example/integration_test/webview_flutter_test.dart b/packages/webview_flutter/example/integration_test/webview_flutter_test.dart
index 4b9fecaee..86ffb6d25 100644
--- a/packages/webview_flutter/example/integration_test/webview_flutter_test.dart
+++ b/packages/webview_flutter/example/integration_test/webview_flutter_test.dart
@@ -34,7 +34,7 @@ void main() {
       ),
     );
     final WebViewController controller = await controllerCompleter.future;
-    final String? currentUrl = await controller.currentUrl();
+    final String currentUrl = await controller.currentUrl();
     expect(currentUrl, 'https://flutter.dev/');
   });
 
@@ -55,7 +55,7 @@ void main() {
     );
     final WebViewController controller = await controllerCompleter.future;
     await controller.loadUrl('https://www.google.com/');
-    final String? currentUrl = await controller.currentUrl();
+    final String currentUrl = await controller.currentUrl();
     expect(currentUrl, 'https://www.google.com/');
   });
 
@@ -89,7 +89,7 @@ void main() {
     };
     await controller.loadUrl('https://flutter-header-echo.herokuapp.com/',
         headers: headers);
-    final String? currentUrl = await controller.currentUrl();
+    final String currentUrl = await controller.currentUrl();
     expect(currentUrl, 'https://flutter-header-echo.herokuapp.com/');
 
     await pageStarts.stream.firstWhere((String url) => url == currentUrl);
@@ -326,7 +326,7 @@ void main() {
   });
 
   group('Video playback policy', () {
-    late String videoTestBase64;
+    String videoTestBase64;
     setUpAll(() async {
       final ByteData videoData =
           await rootBundle.load('assets/sample_video.mp4');
@@ -585,7 +585,7 @@ void main() {
   });
 
   group('Audio playback policy', () {
-    late String audioTestBase64;
+    String audioTestBase64;
     setUpAll(() async {
       final ByteData audioData =
           await rootBundle.load('assets/sample_audio.ogg');
@@ -791,7 +791,7 @@ void main() {
     await pageStarted.future;
     await pageLoaded.future;
 
-    final String? title = await controller.getTitle();
+    final String title = await controller.getTitle();
     expect(title, 'Some title');
   });
 
@@ -1092,7 +1092,7 @@ void main() {
           .evaluateJavascript('location.href = "https://www.google.com/"');
 
       await pageLoads.stream.first; // Wait for the next page load.
-      final String? currentUrl = await controller.currentUrl();
+      final String currentUrl = await controller.currentUrl();
       expect(currentUrl, 'https://www.google.com/');
     });
 
@@ -1183,7 +1183,7 @@ void main() {
       // to give the test a chance to fail.
       await pageLoads.stream.first
           .timeout(const Duration(milliseconds: 500), onTimeout: () => '');
-      final String? currentUrl = await controller.currentUrl();
+      final String currentUrl = await controller.currentUrl();
       expect(currentUrl, isNot(contains('youtube.com')));
     });
 
@@ -1220,7 +1220,7 @@ void main() {
           .evaluateJavascript('location.href = "https://www.google.com"');
 
       await pageLoads.stream.first; // Wait for second page to load.
-      final String? currentUrl = await controller.currentUrl();
+      final String currentUrl = await controller.currentUrl();
       expect(currentUrl, 'https://www.google.com/');
     });
   });
@@ -1247,7 +1247,7 @@ void main() {
       ),
     );
     final WebViewController controller = await controllerCompleter.future;
-    final String? currentUrl = await controller.currentUrl();
+    final String currentUrl = await controller.currentUrl();
     expect(currentUrl, 'https://flutter.dev/');
   });
 
@@ -1274,7 +1274,7 @@ void main() {
     final WebViewController controller = await controllerCompleter.future;
     await controller.evaluateJavascript('window.open("about:blank", "_blank")');
     await pageLoaded.future;
-    final String? currentUrl = await controller.currentUrl();
+    final String currentUrl = await controller.currentUrl();
     expect(currentUrl, 'about:blank');
   });
 
diff --git a/packages/webview_flutter/example/ios/Flutter/AppFrameworkInfo.plist b/packages/webview_flutter/example/ios/Flutter/AppFrameworkInfo.plist
index 9367d483e..8d4492f97 100644
--- a/packages/webview_flutter/example/ios/Flutter/AppFrameworkInfo.plist
+++ b/packages/webview_flutter/example/ios/Flutter/AppFrameworkInfo.plist
@@ -21,6 +21,6 @@
   <key>CFBundleVersion</key>
   <string>1.0</string>
   <key>MinimumOSVersion</key>
-  <string>8.0</string>
+  <string>9.0</string>
 </dict>
 </plist>
diff --git a/packages/webview_flutter/example/ios/Runner.xcodeproj/project.pbxproj b/packages/webview_flutter/example/ios/Runner.xcodeproj/project.pbxproj
index f75e71d17..32d011048 100644
--- a/packages/webview_flutter/example/ios/Runner.xcodeproj/project.pbxproj
+++ b/packages/webview_flutter/example/ios/Runner.xcodeproj/project.pbxproj
@@ -3,7 +3,7 @@
 	archiveVersion = 1;
 	classes = {
 	};
-	objectVersion = 46;
+	objectVersion = 50;
 	objects = {
 
 /* Begin PBXBuildFile section */
@@ -273,7 +273,7 @@
 			isa = PBXProject;
 			attributes = {
 				DefaultBuildSystemTypeForWorkspace = Original;
-				LastUpgradeCheck = 1030;
+				LastUpgradeCheck = 1300;
 				ORGANIZATIONNAME = "The Flutter Authors";
 				TargetAttributes = {
 					68BDCAE823C3F7CB00D9C032 = {
@@ -547,7 +547,7 @@
 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
 				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 8.0;
+				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
 				MTL_ENABLE_DEBUG_INFO = YES;
 				ONLY_ACTIVE_ARCH = YES;
 				SDKROOT = iphoneos;
@@ -597,7 +597,7 @@
 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
 				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 8.0;
+				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
 				MTL_ENABLE_DEBUG_INFO = NO;
 				SDKROOT = iphoneos;
 				TARGETED_DEVICE_FAMILY = "1,2";
diff --git a/packages/webview_flutter/example/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme b/packages/webview_flutter/example/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
index d7453a8ce..cb713d767 100644
--- a/packages/webview_flutter/example/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
+++ b/packages/webview_flutter/example/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <Scheme
-   LastUpgradeVersion = "1030"
+   LastUpgradeVersion = "1300"
    version = "1.3">
    <BuildAction
       parallelizeBuildables = "YES"
diff --git a/packages/webview_flutter/example/lib/main.dart b/packages/webview_flutter/example/lib/main.dart
index 88256cc66..3248cb02b 100644
--- a/packages/webview_flutter/example/lib/main.dart
+++ b/packages/webview_flutter/example/lib/main.dart
@@ -49,8 +49,8 @@ class _WebViewExampleState extends State<WebViewExample> {
         title: const Text('Flutter WebView example'),
         // This drop down menu demonstrates that Flutter widgets can be shown over the web view.
         actions: <Widget>[
-          NavigationControls(_controller.future),
-          SampleMenu(_controller.future),
+          // NavigationControls(_controller.future),
+          // SampleMenu(_controller.future),
         ],
       ),
       // We're using a Builder here so we have a context that is below the Scaffold
@@ -108,7 +108,7 @@ class _WebViewExampleState extends State<WebViewExample> {
           if (controller.hasData) {
             return FloatingActionButton(
               onPressed: () async {
-                final String url = (await controller.data!.currentUrl())!;
+                final String url = (await controller.data.currentUrl());
                 // ignore: deprecated_member_use
                 Scaffold.of(context).showSnackBar(
                   SnackBar(content: Text('Favorited $url')),
@@ -148,25 +148,25 @@ class SampleMenu extends StatelessWidget {
           onSelected: (MenuOptions value) {
             switch (value) {
               case MenuOptions.showUserAgent:
-                _onShowUserAgent(controller.data!, context);
+                _onShowUserAgent(controller.data, context);
                 break;
               case MenuOptions.listCookies:
-                _onListCookies(controller.data!, context);
+                _onListCookies(controller.data, context);
                 break;
               case MenuOptions.clearCookies:
                 _onClearCookies(context);
                 break;
               case MenuOptions.addToCache:
-                _onAddToCache(controller.data!, context);
+                _onAddToCache(controller.data, context);
                 break;
               case MenuOptions.listCache:
-                _onListCache(controller.data!, context);
+                _onListCache(controller.data, context);
                 break;
               case MenuOptions.clearCache:
-                _onClearCache(controller.data!, context);
+                _onClearCache(controller.data, context);
                 break;
               case MenuOptions.navigationDelegate:
-                _onNavigationDelegateExample(controller.data!, context);
+                _onNavigationDelegateExample(controller.data, context);
                 break;
             }
           },
@@ -302,7 +302,7 @@ class NavigationControls extends StatelessWidget {
           (BuildContext context, AsyncSnapshot<WebViewController> snapshot) {
         final bool webViewReady =
             snapshot.connectionState == ConnectionState.done;
-        final WebViewController controller = snapshot.data!;
+        final WebViewController controller = snapshot.data;
         return Row(
           children: <Widget>[
             IconButton(
diff --git a/packages/webview_flutter/example/lib/main1.dart b/packages/webview_flutter/example/lib/main1.dart
new file mode 100644
index 000000000..ba01e8a7f
--- /dev/null
+++ b/packages/webview_flutter/example/lib/main1.dart
@@ -0,0 +1,127 @@
+import 'dart:async';
+import 'package:flutter/material.dart';
+// import 'package:webview_flutter_example/main.dart';
+import 'package:webview_flutter_example/testWeb.dart';
+
+void main() {
+  runApp(const MyApp());
+}
+
+class MyApp extends StatelessWidget {
+  const MyApp({Key key}) : super(key: key);
+
+  // This widget is the root of your application.
+  @override
+  Widget build(BuildContext context) {
+    return MaterialApp(
+      title: 'Flutter Demo',
+      theme: ThemeData(
+        // This is the theme of your application.
+        //
+        // Try running your application with "flutter run". You'll see the
+        // application has a blue toolbar. Then, without quitting the app, try
+        // changing the primarySwatch below to Colors.green and then invoke
+        // "hot reload" (press "r" in the console where you ran "flutter run",
+        // or simply save your changes to "hot reload" in a Flutter IDE).
+        // Notice that the counter didn't reset back to zero; the application
+        // is not restarted.
+        primarySwatch: Colors.blue,
+      ),
+      home: const MyHomePage(title: 'Flutter Demo Home Page'),
+    );
+  }
+}
+
+class MyHomePage extends StatefulWidget {
+  const MyHomePage({Key key, this.title}) : super(key: key);
+
+  // This widget is the home page of your application. It is stateful, meaning
+  // that it has a State object (defined below) that contains fields that affect
+  // how it looks.
+
+  // This class is the configuration for the state. It holds the values (in this
+  // case the title) provided by the parent (in this case the App widget) and
+  // used by the build method of the State. Fields in a Widget subclass are
+  // always marked "final".
+
+  final String title;
+
+  @override
+  State<MyHomePage> createState() => _MyHomePageState();
+}
+
+class _MyHomePageState extends State<MyHomePage> {
+  int _counter = 0;
+
+  void _incrementCounter() {
+    setState(() {
+      // This call to setState tells the Flutter framework that something has
+      // changed in this State, which causes it to rerun the build method below
+      // so that the display can reflect the updated values. If we changed
+      // _counter without calling setState(), then the build method would not be
+      // called again, and so nothing would appear to happen.
+      _counter++;
+    });
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    // This method is rerun every time setState is called, for instance as done
+    // by the _incrementCounter method above.
+    //
+    // The Flutter framework has been optimized to make rerunning build methods
+    // fast, so that you can just rebuild anything that needs updating rather
+    // than having to individually change instances of widgets.
+    return Scaffold(
+      appBar: AppBar(
+        // Here we take the value from the MyHomePage object that was created by
+        // the App.build method, and use it to set our appbar title.
+        title: Text(widget.title),
+      ),
+      body: Center(
+        // Center is a layout widget. It takes a single child and positions it
+        // in the middle of the parent.
+        child: InkWell(
+          onTap: () {
+            Navigator.of(context).push(
+              MaterialPageRoute(
+                builder: (BuildContext context) => WebViewExample(),
+              ),
+            );
+          },
+          child: Column(
+            // Column is also a layout widget. It takes a list of children and
+            // arranges them vertically. By default, it sizes itself to fit its
+            // children horizontally, and tries to be as tall as its parent.
+            //
+            // Invoke "debug painting" (press "p" in the console, choose the
+            // "Toggle Debug Paint" action from the Flutter Inspector in Android
+            // Studio, or the "Toggle Debug Paint" command in Visual Studio Code)
+            // to see the wireframe for each widget.
+            //
+            // Column has various properties to control how it sizes itself and
+            // how it positions its children. Here we use mainAxisAlignment to
+            // center the children vertically; the main axis here is the vertical
+            // axis because Columns are vertical (the cross axis would be
+            // horizontal).
+            mainAxisAlignment: MainAxisAlignment.center,
+            children: <Widget>[
+              const Text(
+                'You have pushed the button this many times:',
+              ),
+              Text(
+                '$_counter',
+                style: Theme.of(context).textTheme.headline4,
+              ),
+            ],
+          ),
+        ),
+      ),
+      floatingActionButton: FloatingActionButton(
+        onPressed: _incrementCounter,
+        tooltip: 'Increment',
+        child: const Icon(Icons.add),
+      ), // This trailing comma makes auto-formatting nicer for build methods.
+    );
+  }
+}
diff --git a/packages/webview_flutter/example/lib/testWeb.dart b/packages/webview_flutter/example/lib/testWeb.dart
new file mode 100644
index 000000000..95c5eb4e1
--- /dev/null
+++ b/packages/webview_flutter/example/lib/testWeb.dart
@@ -0,0 +1,524 @@
+// Copyright 2013 The Flutter Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// ignore_for_file: public_member_api_docs
+
+import 'dart:async';
+import 'dart:convert';
+import 'dart:io';
+import 'dart:typed_data';
+
+import 'package:flutter/material.dart';
+// import 'package:path_provider/path_provider.dart';
+import 'package:webview_flutter/webview_flutter.dart';
+
+// void main() => runApp(const MaterialApp(home: WebViewExample()));
+
+const String kNavigationExamplePage = '''
+<!DOCTYPE html><html>
+<head><title>Navigation Delegate Example</title></head>
+<body>
+<p>
+The navigation delegate is set to block navigation to the youtube website.
+</p>
+<ul>
+<ul><a href="https://www.youtube.com/">https://www.youtube.com/</a></ul>
+<ul><a href="https://www.google.com/">https://www.google.com/</a></ul>
+</ul>
+</body>
+</html>
+''';
+
+const String kLocalExamplePage = '''
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<title>Load file or HTML string example</title>
+</head>
+<body>
+
+<h1>Local demo page</h1>
+<p>
+  This is an example page used to demonstrate how to load a local file or HTML 
+  string using the <a href="https://pub.dev/packages/webview_flutter">Flutter 
+  webview</a> plugin.
+</p>
+
+</body>
+</html>
+''';
+
+const String kTransparentBackgroundPage = '''
+  <!DOCTYPE html>
+  <html>
+  <head>
+    <title>Transparent background test</title>
+  </head>
+  <style type="text/css">
+    body { background: transparent; margin: 0; padding: 0; }
+    #container { position: relative; margin: 0; padding: 0; width: 100vw; height: 100vh; }
+    #shape { background: red; width: 200px; height: 200px; margin: 0; padding: 0; position: absolute; top: calc(50% - 100px); left: calc(50% - 100px); }
+    p { text-align: center; }
+  </style>
+  <body>
+    <div id="container">
+      <p>Transparent background test</p>
+      <div id="shape"></div>
+    </div>
+  </body>
+  </html>
+''';
+
+class WebViewExample extends StatefulWidget {
+  const WebViewExample({this.cookieManager});
+
+  final CookieManager cookieManager;
+
+  @override
+  _WebViewExampleState createState() => _WebViewExampleState();
+}
+
+class _WebViewExampleState extends State<WebViewExample> {
+  final Completer<WebViewController> _controller =
+      Completer<WebViewController>();
+
+  @override
+  void initState() {
+    super.initState();
+    if (Platform.isAndroid) {
+      WebView.platform = SurfaceAndroidWebView();
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return Scaffold(
+      backgroundColor: Colors.green,
+      appBar: AppBar(
+        leading: InkWell(
+          onTap: () {
+            Navigator.of(context).pop();
+          },
+          child: Container(
+            width: kToolbarHeight,
+            height: kToolbarHeight,
+            alignment: AlignmentDirectional.centerStart,
+//        padding: EdgeInsets.only(left:4,right: 10),
+            child: Text(
+              '退出',
+              style: TextStyle(
+                fontSize: 16.0,
+                color: Colors.white,
+              ),
+            ),
+          ),
+        ),
+        title: const Text('Flutter WebView example'),
+        // This drop down menu demonstrates that Flutter widgets can be shown over the web view.
+        actions: <Widget>[
+          NavigationControls(_controller.future),
+          SampleMenu(_controller.future, widget.cookieManager),
+        ],
+      ),
+      body: WebView(
+        initialUrl: 'http://tz-open-game-static.oss-cn-hangzhou.aliyuncs.com/banban/debug/multi/AmongSchoolMulti/index.html?userId=103273507&token=0436Y5__2FbDVaAwVK__2Bc6Jmfg__2FVJU2FTFteM04NoBgInbhBGwIyJSzZspHTfGvq2dHfsLxexOU&safearea=0',//'http://192.168.11.46:8091/h5/AmongSchool/index.html?userId=103273507&token=730eLqVZXmQ34eqJBD0ZMZ3w__2FLKhC9iMgf6Ehez5DPjH5SflwQuCaY4VizzVfi2__2FuWQ7bMc&safearea=0',//'''https://flutter.dev',
+        javascriptMode: JavascriptMode.unrestricted,
+        onWebViewCreated: (WebViewController webViewController) {
+          _controller.complete(webViewController);
+        },
+        onProgress: (int progress) {
+          print('WebView is loading (progress : $progress%)');
+        },
+        javascriptChannels: <JavascriptChannel>{
+          _toasterJavascriptChannel(context),
+        },
+        navigationDelegate: (NavigationRequest request) {
+          if (request.url.startsWith('https://www.youtube.com/')) {
+            print('blocking navigation to $request}');
+            return NavigationDecision.prevent;
+          }
+          print('allowing navigation to $request');
+          return NavigationDecision.navigate;
+        },
+        onPageStarted: (String url) {
+          print('Page started loading: $url');
+        },
+        onPageFinished: (String url) {
+          print('Page finished loading: $url');
+        },
+        gestureNavigationEnabled: true,
+        // backgroundColor: const Color(0x00000000),
+      ),
+      floatingActionButton: favoriteButton(),
+    );
+  }
+
+  JavascriptChannel _toasterJavascriptChannel(BuildContext context) {
+    return JavascriptChannel(
+        name: 'Toaster',
+        onMessageReceived: (JavascriptMessage message) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            SnackBar(content: Text(message.message)),
+          );
+        });
+  }
+
+  Widget favoriteButton() {
+    return FutureBuilder<WebViewController>(
+        future: _controller.future,
+        builder: (BuildContext context,
+            AsyncSnapshot<WebViewController> controller) {
+          return FloatingActionButton(
+            onPressed: () async {
+              String url;
+              if (controller.hasData) {
+                url = (await controller.data.currentUrl());
+              }
+              ScaffoldMessenger.of(context).showSnackBar(
+                SnackBar(
+                  content: Text(
+                    controller.hasData
+                        ? 'Favorited $url'
+                        : 'Unable to favorite',
+                  ),
+                ),
+              );
+            },
+            child: const Icon(Icons.favorite),
+          );
+        });
+  }
+}
+
+enum MenuOptions {
+  showUserAgent,
+  listCookies,
+  clearCookies,
+  addToCache,
+  listCache,
+  clearCache,
+  navigationDelegate,
+  doPostRequest,
+  loadLocalFile,
+  loadFlutterAsset,
+  loadHtmlString,
+  transparentBackground,
+  setCookie,
+}
+
+class SampleMenu extends StatelessWidget {
+  SampleMenu(this.controller, CookieManager cookieManager)
+      : cookieManager = cookieManager ?? CookieManager();
+
+  final Future<WebViewController> controller;
+  final CookieManager cookieManager;
+
+  @override
+  Widget build(BuildContext context) {
+    return FutureBuilder<WebViewController>(
+      future: controller,
+      builder:
+          (BuildContext context, AsyncSnapshot<WebViewController> controller) {
+        return PopupMenuButton<MenuOptions>(
+          key: const ValueKey<String>('ShowPopupMenu'),
+          onSelected: (MenuOptions value) {
+            switch (value) {
+              case MenuOptions.showUserAgent:
+                _onShowUserAgent(controller.data, context);
+                break;
+              case MenuOptions.listCookies:
+                _onListCookies(controller.data, context);
+                break;
+              case MenuOptions.clearCookies:
+                _onClearCookies(context);
+                break;
+              case MenuOptions.addToCache:
+                _onAddToCache(controller.data, context);
+                break;
+              case MenuOptions.listCache:
+                _onListCache(controller.data, context);
+                break;
+              case MenuOptions.clearCache:
+                _onClearCache(controller.data, context);
+                break;
+              case MenuOptions.navigationDelegate:
+                _onNavigationDelegateExample(controller.data, context);
+                break;
+              case MenuOptions.doPostRequest:
+                _onDoPostRequest(controller.data, context);
+                break;
+              case MenuOptions.loadLocalFile:
+                _onLoadLocalFileExample(controller.data, context);
+                break;
+              case MenuOptions.loadFlutterAsset:
+                _onLoadFlutterAssetExample(controller.data, context);
+                break;
+              case MenuOptions.loadHtmlString:
+                _onLoadHtmlStringExample(controller.data, context);
+                break;
+              case MenuOptions.transparentBackground:
+                _onTransparentBackground(controller.data, context);
+                break;
+              case MenuOptions.setCookie:
+                _onSetCookie(controller.data, context);
+                break;
+            }
+          },
+          itemBuilder: (BuildContext context) => <PopupMenuItem<MenuOptions>>[
+            PopupMenuItem<MenuOptions>(
+              value: MenuOptions.showUserAgent,
+              child: const Text('Show user agent'),
+              enabled: controller.hasData,
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.listCookies,
+              child: Text('List cookies'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.clearCookies,
+              child: Text('Clear cookies'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.addToCache,
+              child: Text('Add to cache'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.listCache,
+              child: Text('List cache'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.clearCache,
+              child: Text('Clear cache'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.navigationDelegate,
+              child: Text('Navigation Delegate example'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.doPostRequest,
+              child: Text('Post Request'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.loadHtmlString,
+              child: Text('Load HTML string'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.loadLocalFile,
+              child: Text('Load local file'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.loadFlutterAsset,
+              child: Text('Load Flutter Asset'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              key: ValueKey<String>('ShowTransparentBackgroundExample'),
+              value: MenuOptions.transparentBackground,
+              child: Text('Transparent background example'),
+            ),
+            const PopupMenuItem<MenuOptions>(
+              value: MenuOptions.setCookie,
+              child: Text('Set cookie'),
+            ),
+          ],
+        );
+      },
+    );
+  }
+
+  Future<void> _onShowUserAgent(
+      WebViewController controller, BuildContext context) async {
+    // Send a message with the user agent string to the Toaster JavaScript channel we registered
+    // with the WebView.
+    // await controller.runJavascript(
+    //     'Toaster.postMessage("User Agent: " + navigator.userAgent);');
+  }
+
+  Future<void> _onListCookies(
+      WebViewController controller, BuildContext context) async {
+    // final String cookies =
+    //     await controller.runJavascriptReturningResult('document.cookie');
+    // ScaffoldMessenger.of(context).showSnackBar(SnackBar(
+    //   content: Column(
+    //     mainAxisAlignment: MainAxisAlignment.end,
+    //     mainAxisSize: MainAxisSize.min,
+    //     children: <Widget>[
+    //       const Text('Cookies:'),
+    //       _getCookieList(cookies),
+    //     ],
+    //   ),
+    // ));
+  }
+
+  Future<void> _onAddToCache(
+      WebViewController controller, BuildContext context) async {
+    // await controller.runJavascript(
+    //     'caches.open("test_caches_entry"); localStorage["test_localStorage"] = "dummy_entry";');
+    // ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
+    //   content: Text('Added a test entry to cache.'),
+    // ));
+  }
+
+  Future<void> _onListCache(
+      WebViewController controller, BuildContext context) async {
+    // await controller.runJavascript('caches.keys()'
+    //     '.then((cacheKeys) => JSON.stringify({"cacheKeys" : cacheKeys, "localStorage" : localStorage}))'
+    //     '.then((caches) => Toaster.postMessage(caches))');
+  }
+
+  Future<void> _onClearCache(
+      WebViewController controller, BuildContext context) async {
+    await controller.clearCache();
+    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
+      content: Text('Cache cleared.'),
+    ));
+  }
+
+  Future<void> _onClearCookies(BuildContext context) async {
+    final bool hadCookies = await cookieManager.clearCookies();
+    String message = 'There were cookies. Now, they are gone!';
+    if (!hadCookies) {
+      message = 'There are no cookies.';
+    }
+    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
+      content: Text(message),
+    ));
+  }
+
+  Future<void> _onNavigationDelegateExample(
+      WebViewController controller, BuildContext context) async {
+    final String contentBase64 =
+        base64Encode(const Utf8Encoder().convert(kNavigationExamplePage));
+    await controller.loadUrl('data:text/html;base64,$contentBase64');
+  }
+
+  Future<void> _onSetCookie(
+      WebViewController controller, BuildContext context) async {
+    // await cookieManager.setCookie(
+    //   const WebViewCookie(
+    //       name: 'foo', value: 'bar', domain: 'httpbin.org', path: '/anything'),
+    // );
+    // await controller.loadUrl('https://httpbin.org/anything');
+  }
+
+  Future<void> _onDoPostRequest(
+      WebViewController controller, BuildContext context) async {
+    // final WebViewRequest request = WebViewRequest(
+    //   uri: Uri.parse('https://httpbin.org/post'),
+    //   method: WebViewRequestMethod.post,
+    //   headers: <String, String>{'foo': 'bar', 'Content-Type': 'text/plain'},
+    //   body: Uint8List.fromList('Test Body'.codeUnits),
+    // );
+    // await controller.loadRequest(request);
+  }
+
+  Future<void> _onLoadLocalFileExample(
+      WebViewController controller, BuildContext context) async {
+    // final String pathToIndex = await _prepareLocalFile();
+    //
+    // await controller.loadFile(pathToIndex);
+  }
+
+  Future<void> _onLoadFlutterAssetExample(
+      WebViewController controller, BuildContext context) async {
+    // await controller.loadFlutterAsset('assets/www/index.html');
+  }
+
+  Future<void> _onLoadHtmlStringExample(
+      WebViewController controller, BuildContext context) async {
+    // await controller.loadHtmlString(kLocalExamplePage);
+  }
+
+  Future<void> _onTransparentBackground(
+      WebViewController controller, BuildContext context) async {
+    // await controller.loadHtmlString(kTransparentBackgroundPage);
+  }
+
+  Widget _getCookieList(String cookies) {
+    if (cookies == null || cookies == '""') {
+      return Container();
+    }
+    final List<String> cookieList = cookies.split(';');
+    final Iterable<Text> cookieWidgets =
+        cookieList.map((String cookie) => Text(cookie));
+    return Column(
+      mainAxisAlignment: MainAxisAlignment.end,
+      mainAxisSize: MainAxisSize.min,
+      children: cookieWidgets.toList(),
+    );
+  }
+
+  // static Future<String> _prepareLocalFile() async {
+  //   final String tmpDir = (await getTemporaryDirectory()).path;
+  //   final File indexFile = File(
+  //       <String>{tmpDir, 'www', 'index.html'}.join(Platform.pathSeparator));
+  //
+  //   await indexFile.create(recursive: true);
+  //   await indexFile.writeAsString(kLocalExamplePage);
+  //
+  //   return indexFile.path;
+  // }
+}
+
+class NavigationControls extends StatelessWidget {
+  const NavigationControls(this._webViewControllerFuture)
+      : assert(_webViewControllerFuture != null);
+
+  final Future<WebViewController> _webViewControllerFuture;
+
+  @override
+  Widget build(BuildContext context) {
+    return FutureBuilder<WebViewController>(
+      future: _webViewControllerFuture,
+      builder:
+          (BuildContext context, AsyncSnapshot<WebViewController> snapshot) {
+        final bool webViewReady =
+            snapshot.connectionState == ConnectionState.done;
+        final WebViewController controller = snapshot.data;
+        return Row(
+          children: <Widget>[
+            IconButton(
+              icon: const Icon(Icons.arrow_back_ios),
+              onPressed: !webViewReady
+                  ? null
+                  : () async {
+                      if (await controller.canGoBack()) {
+                        await controller.goBack();
+                      } else {
+                        ScaffoldMessenger.of(context).showSnackBar(
+                          const SnackBar(content: Text('No back history item')),
+                        );
+                        return;
+                      }
+                    },
+            ),
+            IconButton(
+              icon: const Icon(Icons.arrow_forward_ios),
+              onPressed: !webViewReady
+                  ? null
+                  : () async {
+                      if (await controller.canGoForward()) {
+                        await controller.goForward();
+                      } else {
+                        ScaffoldMessenger.of(context).showSnackBar(
+                          const SnackBar(
+                              content: Text('No forward history item')),
+                        );
+                        return;
+                      }
+                    },
+            ),
+            IconButton(
+              icon: const Icon(Icons.replay),
+              onPressed: !webViewReady
+                  ? null
+                  : () {
+                      controller.reload();
+                    },
+            ),
+          ],
+        );
+      },
+    );
+  }
+}
diff --git a/packages/webview_flutter/example/pubspec.yaml b/packages/webview_flutter/example/pubspec.yaml
index 3529ecc06..3ee3e9dae 100644
--- a/packages/webview_flutter/example/pubspec.yaml
+++ b/packages/webview_flutter/example/pubspec.yaml
@@ -3,7 +3,7 @@ description: Demonstrates how to use the webview_flutter plugin.
 publish_to: none
 
 environment:
-  sdk: ">=2.12.0 <3.0.0"
+  sdk: '>=2.10.0 <3.0.0'
 
 dependencies:
   flutter:
diff --git a/packages/webview_flutter/ios/Classes/FLTGestureInterceptView.h b/packages/webview_flutter/ios/Classes/FLTGestureInterceptView.h
new file mode 100644
index 000000000..97b09919b
--- /dev/null
+++ b/packages/webview_flutter/ios/Classes/FLTGestureInterceptView.h
@@ -0,0 +1,18 @@
+//
+//  FLTGestureInterceptView.h
+//  webview_flutter
+//
+//  Created by 陈恩裕 on 2022/6/9.
+//
+
+#import <UIKit/UIKit.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface FLTGestureInterceptView : UIView
+
+
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/packages/webview_flutter/ios/Classes/FLTGestureInterceptView.m b/packages/webview_flutter/ios/Classes/FLTGestureInterceptView.m
new file mode 100644
index 000000000..2e9c6562e
--- /dev/null
+++ b/packages/webview_flutter/ios/Classes/FLTGestureInterceptView.m
@@ -0,0 +1,76 @@
+//
+//  FLTGestureInterceptView.m
+//  webview_flutter
+//  用于解决webview上面盖有flutter widget时，对widget执行的手势操作会被透传到webview(platformview)
+//
+//  Created by 陈恩裕 on 2022/6/9.
+//
+
+#import "FLTGestureInterceptView.h"
+
+@implementation FLTGestureInterceptView
+
+{
+    NSMutableArray<UIView*> *_overlayViews;
+}
+
+// 查找FlutterOverlayView
+// 深度优先遍历(先序)
+-(void)findFlutterOverlayView:(UIView*)superView{
+    for(int i=0;i<superView.subviews.count;i++){
+        UIView *subView = superView.subviews[i];
+        // 先查找到自己，在自己上层的才可以放入数组
+        if(subView == self){
+            _overlayViews = @[].mutableCopy;
+        }
+        if(_overlayViews){
+            NSString *className = NSStringFromClass([subView class]);
+            if([className isEqualToString:@"FlutterOverlayView"]){
+                // subview的clipsToBounds = YES; 用来裁剪子view
+                [_overlayViews addObject:subView];
+                // 如果找到了，就不需要递归查找自己的子view
+                // 经调试发现，子view是一个frame为全屏的FlutterOverlayView，会影响坐标判断，所以只记录当前view即可
+                continue;
+            }
+        }
+        [self findFlutterOverlayView:subView];
+    }
+}
+
+- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event{
+    _overlayViews = nil; // 每次点击事件，都要重置数组
+    UIView *rootView = [UIApplication sharedApplication].keyWindow;
+    [self findFlutterOverlayView:rootView];
+
+    // 从后往前找，即从上往下
+    for(NSInteger i = _overlayViews.count - 1; i >= 0; i--){
+        UIView *subView = _overlayViews[i];
+        CGPoint p = [self getGlobalPoint:point OfView:self];
+        if(CGRectContainsPoint([self getGlobalFrameOfView:subView], p)){
+            return subView;
+        }
+    }
+    return [super hitTest:point withEvent:event];
+}
+
+-(CGPoint)getGlobalPoint:(CGPoint)point OfView:(UIView*)view{
+    UIView *superView = view;
+    CGPoint globalPoint = point;
+    while (superView) {
+        globalPoint = CGPointMake(globalPoint.x+superView.frame.origin.x, globalPoint.y+superView.frame.origin.y);
+        superView = superView.superview;
+    }
+    return globalPoint;
+}
+
+-(CGRect)getGlobalFrameOfView:(UIView*)view{
+    CGRect globalFrame = view.frame;
+    UIView *superView = view.superview;
+    while (superView) {
+        globalFrame = CGRectMake(globalFrame.origin.x+superView.frame.origin.x, globalFrame.origin.y+superView.frame.origin.y, globalFrame.size.width, globalFrame.size.height);
+        superView = superView.superview;
+    }
+    return globalFrame;
+}
+
+@end
diff --git a/packages/webview_flutter/ios/Classes/FLTWKNavigationDelegate.m b/packages/webview_flutter/ios/Classes/FLTWKNavigationDelegate.m
index 8b7ee7d0c..5412d46b3 100644
--- a/packages/webview_flutter/ios/Classes/FLTWKNavigationDelegate.m
+++ b/packages/webview_flutter/ios/Classes/FLTWKNavigationDelegate.m
@@ -4,14 +4,18 @@
 
 #import "FLTWKNavigationDelegate.h"
 
+NSString *const BRIDGE_NAME = @"Bridge";
+
 @implementation FLTWKNavigationDelegate {
   FlutterMethodChannel *_methodChannel;
+    Boolean _notInitBridge;
 }
 
 - (instancetype)initWithChannel:(FlutterMethodChannel *)channel {
   self = [super init];
   if (self) {
     _methodChannel = channel;
+      _notInitBridge = TRUE;
   }
   return self;
 }
@@ -22,9 +26,46 @@
   [_methodChannel invokeMethod:@"onPageStarted" arguments:@{@"url" : webView.URL.absoluteString}];
 }
 
+- (NSDictionary *)getUrlParameterWithUrl:(NSURL *)url {
+    NSMutableDictionary *parm = [[NSMutableDictionary alloc]init];
+    //传入url创建url组件类
+    NSURLComponents *urlComponents = [[NSURLComponents alloc] initWithString:url.absoluteString];
+    //回调遍历所有参数，添加入字典
+    [urlComponents.queryItems enumerateObjectsUsingBlock:^(NSURLQueryItem * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
+        if (obj.value != nil) {
+            [parm setObject:obj.value forKey:obj.name];
+        }
+    }];
+    return parm;
+}
+
+// 在发送请求之前，决定是否跳转
 - (void)webView:(WKWebView *)webView
     decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction
                     decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
+    
+    NSLog(@"decidePolicyForNavigationAction%@",navigationAction.request.URL.absoluteString);
+
+    NSDictionary *params = [self getUrlParameterWithUrl:navigationAction.request.URL];
+    NSString *clientDownload = [params objectForKey:@"clientDownload"];
+    if ([navigationAction.request.URL.absoluteString hasPrefix:@"weixin://dl/business"]) {
+        decisionHandler(WKNavigationActionPolicyCancel);
+        NSURL *url = [NSURL URLWithString:navigationAction.request.URL.absoluteString];
+        if ([[UIApplication sharedApplication] canOpenURL:url]) {
+            [[UIApplication sharedApplication] openURL:[NSURL URLWithString:navigationAction.request.URL.absoluteString]];
+        }
+        return;
+    } else if ([@"1" isEqualToString:clientDownload]) {
+        // 跟前端约定好，url里的querystring里带了clientDownload=1参数,就认为是要下载的链接
+        decisionHandler(WKNavigationActionPolicyCancel);
+        NSURL *url = [NSURL URLWithString:navigationAction.request.URL.absoluteString];
+        if ([[UIApplication sharedApplication] canOpenURL:url]) {
+            [[UIApplication sharedApplication] openURL:[NSURL URLWithString:navigationAction.request.URL.absoluteString]];
+        }
+        return;
+    }
+
+    
   if (!self.hasDartNavigationDelegate) {
     decisionHandler(WKNavigationActionPolicyAllow);
     return;
@@ -64,6 +105,16 @@
 
 - (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {
   [_methodChannel invokeMethod:@"onPageFinished" arguments:@{@"url" : webView.URL.absoluteString}];
+    if (_notInitBridge) {
+        _notInitBridge = FALSE;
+        //注入默认的bridge
+        NSString *jsBridge = [NSString stringWithFormat:
+                              @"window.originalPostMessage = window.postMessage;"
+                              "window.postMessage = function(data) {"
+                              "%@.postMessage(JSON.stringify(data));"
+                              "};", BRIDGE_NAME];
+        [webView evaluateJavaScript:jsBridge completionHandler:nil];
+    }
 }
 
 + (id)errorCodeToString:(NSUInteger)code {
diff --git a/packages/webview_flutter/ios/Classes/FlutterWebView.m b/packages/webview_flutter/ios/Classes/FlutterWebView.m
index c6d926d3c..e28748161 100644
--- a/packages/webview_flutter/ios/Classes/FlutterWebView.m
+++ b/packages/webview_flutter/ios/Classes/FlutterWebView.m
@@ -6,6 +6,7 @@
 #import "FLTWKNavigationDelegate.h"
 #import "FLTWKProgressionDelegate.h"
 #import "JavaScriptChannelHandler.h"
+#import "FLTGestureInterceptView.h"
 
 @implementation FLTWebViewFactory {
   NSObject<FlutterBinaryMessenger>* _messenger;
@@ -57,6 +58,13 @@
 
 @end
 
+// UIWebViewDelegate
+@interface FLTWebViewController() <WKNavigationDelegate, UIScrollViewDelegate, WKUIDelegate> {
+    BOOL _enableZoom;
+    NSDictionary<NSString*, NSString*> *_headers;
+}
+@end
+
 @implementation FLTWebViewController {
   FLTWKWebView* _webView;
   int64_t _viewId;
@@ -66,6 +74,7 @@
   NSMutableSet* _javaScriptChannelNames;
   FLTWKNavigationDelegate* _navigationDelegate;
   FLTWKProgressionDelegate* _progressionDelegate;
+  FLTGestureInterceptView *_gestureInterceptView;
 }
 
 - (instancetype)initWithFrame:(CGRect)frame
@@ -93,11 +102,43 @@
     configuration.userContentController = userContentController;
     [self updateAutoMediaPlaybackPolicy:args[@"autoMediaPlaybackPolicy"]
                         inConfiguration:configuration];
+    configuration.allowsInlineMediaPlayback = ![args[@"iosVideoFullScreen"] boolValue];
+    [configuration.preferences setValue:@"TRUE" forKey:@"allowFileAccessFromFileURLs"];
+    [configuration setValue:@"TRUE" forKey:@"allowUniversalAccessFromFileURLs"];
+
 
     _webView = [[FLTWKWebView alloc] initWithFrame:frame configuration:configuration];
     _navigationDelegate = [[FLTWKNavigationDelegate alloc] initWithChannel:_channel];
+    // Background color
+    NSNumber* backgroundColorNSNumber = args[@"backgroundColor"];
+    if ([backgroundColorNSNumber isKindOfClass:[NSNumber class]]) {
+      int backgroundColorInt = [backgroundColorNSNumber intValue];
+      UIColor* backgroundColor = [UIColor colorWithRed:(backgroundColorInt >> 16 & 0xff) / 255.0
+                                                 green:(backgroundColorInt >> 8 & 0xff) / 255.0
+                                                  blue:(backgroundColorInt & 0xff) / 255.0
+                                                 alpha:(backgroundColorInt >> 24 & 0xff) / 255.0];
+      _webView.opaque = NO;
+      _webView.backgroundColor = UIColor.clearColor;
+      _webView.scrollView.backgroundColor = backgroundColor;
+    } else {
+      _webView.opaque = NO;
+      _webView.backgroundColor = UIColor.clearColor;
+      _webView.scrollView.backgroundColor = UIColor.clearColor;
+    }
+
     _webView.UIDelegate = self;
     _webView.navigationDelegate = _navigationDelegate;
+    _webView.scrollView.delegate = self;
+    _webView.scrollView.bounces = false;
+
+//    // 拦截透传过来的手势
+//    _gestureInterceptView = [FLTGestureInterceptView new];
+//    [_gestureInterceptView addSubview:_webView];
+//    _gestureInterceptView.frame = frame;
+//    _gestureInterceptView.autoresizesSubviews = YES;
+//    _gestureInterceptView.translatesAutoresizingMaskIntoConstraints = NO;
+//    _webView.autoresizingMask = UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight;
+
     __weak __typeof__(self) weakSelf = self;
     [_channel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) {
       [weakSelf onMethodCall:call result:result];
@@ -116,18 +157,16 @@
 
     NSString* initialUrl = args[@"initialUrl"];
     if ([initialUrl isKindOfClass:[NSString class]]) {
-      [self loadUrl:initialUrl];
+        if (_headers != nil) {
+            [self loadUrl:initialUrl withHeaders:_headers];
+        } else {
+            [self loadUrl:initialUrl];
+        }
     }
   }
   return self;
 }
 
-- (void)dealloc {
-  if (_progressionDelegate != nil) {
-    [_progressionDelegate stopObservingProgress:_webView];
-  }
-}
-
 - (UIView*)view {
   return _webView;
 }
@@ -193,13 +232,13 @@
 }
 
 - (void)onCanGoBack:(FlutterMethodCall*)call result:(FlutterResult)result {
-  BOOL canGoBack = [_webView canGoBack];
-  result(@(canGoBack));
+    BOOL canGoBack = [_webView canGoBack];
+    result([NSNumber numberWithBool:canGoBack]);
 }
 
 - (void)onCanGoForward:(FlutterMethodCall*)call result:(FlutterResult)result {
-  BOOL canGoForward = [_webView canGoForward];
-  result(@(canGoForward));
+    BOOL canGoForward = [_webView canGoForward];
+    result([NSNumber numberWithBool:canGoForward]);
 }
 
 - (void)onGoBack:(FlutterMethodCall*)call result:(FlutterResult)result {
@@ -314,12 +353,12 @@
 
 - (void)getScrollX:(FlutterMethodCall*)call result:(FlutterResult)result {
   int offsetX = _webView.scrollView.contentOffset.x;
-  result(@(offsetX));
+    result([NSNumber numberWithInt:offsetX]);
 }
 
 - (void)getScrollY:(FlutterMethodCall*)call result:(FlutterResult)result {
   int offsetY = _webView.scrollView.contentOffset.y;
-  result(@(offsetY));
+    result([NSNumber numberWithInt:offsetY]);
 }
 
 // Returns nil when successful, or an error message when one or more keys are unknown.
@@ -348,7 +387,15 @@
     } else if ([key isEqualToString:@"userAgent"]) {
       NSString* userAgent = settings[key];
       [self updateUserAgent:[userAgent isEqual:[NSNull null]] ? nil : userAgent];
-    } else {
+    } else if ([key isEqualToString:@"headers"]) {
+        NSDictionary *headers = settings[key];
+        if (headers != nil) {
+            _headers = headers;
+        }
+    } else if ([key isEqualToString:@"supportZoom"]) {
+        NSNumber *withZoom = settings[key];
+        _enableZoom = [withZoom boolValue];
+    }  else {
       [unknownKeys addObject:key];
     }
   }
@@ -444,6 +491,13 @@
   if (!nsUrl) {
     return false;
   }
+    if(nsUrl.fileURL){
+        if (@available(iOS 9.0, *)) {
+            [_webView loadFileURL:nsUrl allowingReadAccessToURL:[nsUrl URLByDeletingLastPathComponent]];
+            return true;
+        }
+    }
+    
   NSMutableURLRequest* request = [NSMutableURLRequest requestWithURL:nsUrl];
   [request setAllHTTPHeaderFields:headers];
   [_webView loadRequest:request];
@@ -475,6 +529,13 @@
   }
 }
 
+#pragma mark -- UIScrollViewDelegate
+- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {
+    if (scrollView.pinchGestureRecognizer.isEnabled != _enableZoom) {
+        scrollView.pinchGestureRecognizer.enabled = _enableZoom;
+    }
+}
+
 #pragma mark WKUIDelegate
 
 - (WKWebView*)webView:(WKWebView*)webView
@@ -488,4 +549,14 @@
   return nil;
 }
 
+-(void)dealloc{
+    if (_progressionDelegate != nil) {
+      [_progressionDelegate stopObservingProgress:_webView];
+    }
+    if (@available(iOS 10, *)) {
+    }else{
+        _webView.scrollView.delegate = nil;
+    }
+}
+
 @end
diff --git a/packages/webview_flutter/ios/Classes/JavaScriptChannelHandler.h b/packages/webview_flutter/ios/Classes/JavaScriptChannelHandler.h
index a0a5ec657..b3213521d 100644
--- a/packages/webview_flutter/ios/Classes/JavaScriptChannelHandler.h
+++ b/packages/webview_flutter/ios/Classes/JavaScriptChannelHandler.h
@@ -12,6 +12,8 @@ NS_ASSUME_NONNULL_BEGIN
 - (instancetype)initWithMethodChannel:(FlutterMethodChannel*)methodChannel
                 javaScriptChannelName:(NSString*)javaScriptChannelName;
 
+- (void)invoke:(NSString *)params;
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/packages/webview_flutter/ios/Classes/JavaScriptChannelHandler.m b/packages/webview_flutter/ios/Classes/JavaScriptChannelHandler.m
index ec9a363a4..4847e6898 100644
--- a/packages/webview_flutter/ios/Classes/JavaScriptChannelHandler.m
+++ b/packages/webview_flutter/ios/Classes/JavaScriptChannelHandler.m
@@ -33,4 +33,13 @@
   [_methodChannel invokeMethod:@"javascriptChannelMessage" arguments:arguments];
 }
 
+- (void)invoke:(NSString *)params{
+    NSDictionary* arguments = @{
+                                @"channel" : _javaScriptChannelName,
+                                @"message" : [NSString stringWithFormat:@"%@", params]
+                                };
+    [_methodChannel invokeMethod:@"javascriptChannelMessage" arguments:arguments];
+
+}
+
 @end
diff --git a/packages/webview_flutter/ios/Tests/FLTWebViewTests.m b/packages/webview_flutter/ios/Tests/FLTWebViewTests.m
new file mode 100644
index 000000000..5caea9626
--- /dev/null
+++ b/packages/webview_flutter/ios/Tests/FLTWebViewTests.m
@@ -0,0 +1,38 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+@import Flutter;
+@import OCMock;
+@import XCTest;
+@import webview_flutter;
+
+@interface FLTWebViewTests : XCTestCase
+
+@property(strong, nonatomic) NSObject<FlutterBinaryMessenger> *mockBinaryMessenger;
+
+@end
+
+@implementation FLTWebViewTests
+
+- (void)setUp {
+  [super setUp];
+  self.mockBinaryMessenger = OCMProtocolMock(@protocol(FlutterBinaryMessenger));
+}
+
+- (void)canInitFLTWebViewController {
+  FLTWebViewController *controller =
+      [[FLTWebViewController alloc] initWithFrame:CGRectMake(0, 0, 300, 400)
+                                   viewIdentifier:1
+                                        arguments:nil
+                                  binaryMessenger:self.mockBinaryMessenger];
+  XCTAssertNotNil(controller);
+}
+
+- (void)canInitFLTWebViewFactory {
+  FLTWebViewFactory *factory =
+      [[FLTWebViewFactory alloc] initWithMessenger:self.mockBinaryMessenger];
+  XCTAssertNotNil(factory);
+}
+
+@end
diff --git a/packages/webview_flutter/ios/webview_flutter.podspec b/packages/webview_flutter/ios/webview_flutter.podspec
index 1602f1c43..469195ae6 100644
--- a/packages/webview_flutter/ios/webview_flutter.podspec
+++ b/packages/webview_flutter/ios/webview_flutter.podspec
@@ -19,5 +19,10 @@ Downloaded by pub (not CocoaPods).
   s.dependency 'Flutter'
 
   s.platform = :ios, '8.0'
-  s.pod_target_xcconfig = { 'DEFINES_MODULE' => 'YES', 'EXCLUDED_ARCHS[sdk=iphonesimulator*]' => 'i386' }
+  s.pod_target_xcconfig = { 'DEFINES_MODULE' => 'YES', 'VALID_ARCHS[sdk=iphonesimulator*]' => 'x86_64' }
+
+  s.test_spec 'Tests' do |test_spec|
+    test_spec.source_files = 'Tests/**/*'
+    test_spec.dependency 'OCMock','3.5'
+  end
 end
diff --git a/packages/webview_flutter/lib/platform_interface.dart b/packages/webview_flutter/lib/platform_interface.dart
index 92aa87b74..bd8749887 100644
--- a/packages/webview_flutter/lib/platform_interface.dart
+++ b/packages/webview_flutter/lib/platform_interface.dart
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -8,6 +8,7 @@ import 'package:flutter/foundation.dart';
 import 'package:flutter/gestures.dart';
 import 'package:flutter/widgets.dart';
 
+import 'webview_flutter.dart';
 import 'webview_flutter.dart';
 
 /// Interface for callbacks made by [WebViewPlatformController].
@@ -21,8 +22,7 @@ abstract class WebViewPlatformCallbacksHandler {
   /// Invoked by [WebViewPlatformController] when a navigation request is pending.
   ///
   /// If true is returned the navigation is allowed, otherwise it is blocked.
-  FutureOr<bool> onNavigationRequest(
-      {required String url, required bool isForMainFrame});
+  FutureOr<bool> onNavigationRequest({@required String url, @required bool isForMainFrame});
 
   /// Invoked by [WebViewPlatformController] when a page has started loading.
   void onPageStarted(String url);
@@ -36,6 +36,10 @@ abstract class WebViewPlatformCallbacksHandler {
 
   /// Report web resource loading error to the host application.
   void onWebResourceError(WebResourceError error);
+
+  void onWebError(WebError webError);
+
+  void onWebHttpError(WebError httpError);
 }
 
 /// Possible error type categorizations used by [WebResourceError].
@@ -101,6 +105,14 @@ enum WebResourceErrorType {
   javaScriptResultTypeIsUnsupported,
 }
 
+class WebError{
+  String url;
+  String msg;
+  int code;
+
+  WebError({this.code, this.url,this.msg});
+}
+
 /// Error returned in `WebView.onWebResourceError` when a web resource loading error has occurred.
 class WebResourceError {
   /// Creates a new [WebResourceError]
@@ -108,8 +120,8 @@ class WebResourceError {
   /// A user should not need to instantiate this class, but will receive one in
   /// [WebResourceErrorCallback].
   WebResourceError({
-    required this.errorCode,
-    required this.description,
+    @required this.errorCode,
+    @required this.description,
     this.domain,
     this.errorType,
     this.failingUrl,
@@ -136,7 +148,7 @@ class WebResourceError {
   /// in Objective-C. See
   /// https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorObjectsDomains/ErrorObjectsDomains.html
   /// for more information on error handling on iOS.
-  final String? domain;
+  final String domain;
 
   /// Description of the error that can be used to communicate the problem to the user.
   final String description;
@@ -144,13 +156,13 @@ class WebResourceError {
   /// The type this error can be categorized as.
   ///
   /// This will never be `null` on Android, but can be `null` on iOS.
-  final WebResourceErrorType? errorType;
+  final WebResourceErrorType errorType;
 
   /// Gets the URL for which the resource request was made.
   ///
   /// This value is not provided on iOS. Alternatively, you can keep track of
   /// the last values provided to [WebViewPlatformController.loadUrl].
-  final String? failingUrl;
+  final String failingUrl;
 }
 
 /// Interface for talking to the webview's platform implementation.
@@ -181,7 +193,7 @@ abstract class WebViewPlatformController {
   /// Throws an ArgumentError if `url` is not a valid URL string.
   Future<void> loadUrl(
     String url,
-    Map<String, String>? headers,
+    Map<String, String> headers,
   ) {
     throw UnimplementedError(
         "WebView loadUrl is not implemented on the current platform");
@@ -199,7 +211,7 @@ abstract class WebViewPlatformController {
   /// Accessor to the current URL that the WebView is displaying.
   ///
   /// If no URL was ever loaded, returns `null`.
-  Future<String?> currentUrl() {
+  Future<String> currentUrl() {
     throw UnimplementedError(
         "WebView currentUrl is not implemented on the current platform");
   }
@@ -286,7 +298,7 @@ abstract class WebViewPlatformController {
   }
 
   /// Returns the title of the currently loaded page.
-  Future<String?> getTitle() {
+  Future<String> getTitle() {
     throw UnimplementedError(
         "WebView getTitle is not implemented on the current platform");
   }
@@ -322,6 +334,8 @@ abstract class WebViewPlatformController {
     throw UnimplementedError(
         "WebView getScrollY is not implemented on the current platform");
   }
+
+  void dispose() {}
 }
 
 /// A single setting for configuring a WebViewPlatform which may be absent.
@@ -331,7 +345,7 @@ class WebSetting<T> {
   /// The [isPresent] field for the instance will be false.
   ///
   /// Accessing [value] for an absent instance will throw.
-  WebSetting.absent()
+  const WebSetting.absent()
       : _value = null,
         isPresent = false;
 
@@ -342,7 +356,7 @@ class WebSetting<T> {
       : _value = value,
         isPresent = true;
 
-  final T? _value;
+  final T _value;
 
   /// The setting's value.
   ///
@@ -390,34 +404,40 @@ class WebSettings {
   ///
   /// The `userAgent` parameter must not be null.
   WebSettings({
-    this.javascriptMode,
-    this.hasNavigationDelegate,
+    this.javascriptMode=JavascriptMode.disabled,
+    this.hasNavigationDelegate=false,
     this.hasProgressTracking,
-    this.debuggingEnabled,
-    this.gestureNavigationEnabled,
+    this.debuggingEnabled=false,
+    this.gestureNavigationEnabled=false,
     this.allowsInlineMediaPlayback,
-    required this.userAgent,
-  }) : assert(userAgent != null);
+    this.userAgent,
+    this.headers,
+    this.supportZoom = false
+  }){
+    if(userAgent == null){
+      userAgent = WebSetting.of('');
+    }
+  }
 
   /// The JavaScript execution mode to be used by the webview.
-  final JavascriptMode? javascriptMode;
+  final JavascriptMode javascriptMode;
 
   /// Whether the [WebView] has a [NavigationDelegate] set.
-  final bool? hasNavigationDelegate;
+  final bool hasNavigationDelegate;
 
   /// Whether the [WebView] should track page loading progress.
   /// See also: [WebViewPlatformCallbacksHandler.onProgress] to get the progress.
-  final bool? hasProgressTracking;
+  final bool hasProgressTracking;
 
   /// Whether to enable the platform's webview content debugging tools.
   ///
   /// See also: [WebView.debuggingEnabled].
-  final bool? debuggingEnabled;
+  final bool debuggingEnabled;
 
   /// Whether to play HTML5 videos inline or use the native full-screen controller on iOS.
   ///
   /// This will have no effect on Android.
-  final bool? allowsInlineMediaPlayback;
+  final bool allowsInlineMediaPlayback;
 
   /// The value used for the HTTP `User-Agent:` request header.
   ///
@@ -427,16 +447,20 @@ class WebSettings {
   /// last time it was set.
   ///
   /// See also [WebView.userAgent].
-  final WebSetting<String?> userAgent;
+  WebSetting<String> userAgent;
 
   /// Whether to allow swipe based navigation in iOS.
   ///
   /// See also: [WebView.gestureNavigationEnabled]
-  final bool? gestureNavigationEnabled;
+  final bool gestureNavigationEnabled;
+
+  Map<String,String> headers;
+
+  bool supportZoom;
 
   @override
   String toString() {
-    return 'WebSettings(javascriptMode: $javascriptMode, hasNavigationDelegate: $hasNavigationDelegate, hasProgressTracking: $hasProgressTracking, debuggingEnabled: $debuggingEnabled, gestureNavigationEnabled: $gestureNavigationEnabled, userAgent: $userAgent, allowsInlineMediaPlayback: $allowsInlineMediaPlayback)';
+    return 'WebSettings(javascriptMode: $javascriptMode, hasNavigationDelegate: $hasNavigationDelegate, hasProgressTracking: $hasProgressTracking, debuggingEnabled: $debuggingEnabled, gestureNavigationEnabled: $gestureNavigationEnabled, userAgent: $userAgent, allowsInlineMediaPlayback: $allowsInlineMediaPlayback)';;
   }
 }
 
@@ -455,17 +479,21 @@ class CreationParams {
     this.userAgent,
     this.autoMediaPlaybackPolicy =
         AutoMediaPlaybackPolicy.require_user_action_for_all_media_types,
+    this.iosVideoFullScreen = false,
+    this.useAndroidDefaultChromeClient = false,
+    this.androidCornerRadius,
+    this.backgroundColor,
   }) : assert(autoMediaPlaybackPolicy != null);
 
   /// The initialUrl to load in the webview.
   ///
   /// When null the webview will be created without loading any page.
-  final String? initialUrl;
+  final String initialUrl;
 
   /// The initial [WebSettings] for the new webview.
   ///
   /// This can later be updated with [WebViewPlatformController.updateSettings].
-  final WebSettings? webSettings;
+  final WebSettings webSettings;
 
   /// The initial set of JavaScript channels that are configured for this webview.
   ///
@@ -483,22 +511,32 @@ class CreationParams {
   /// The value used for the HTTP User-Agent: request header.
   ///
   /// When null the platform's webview default is used for the User-Agent header.
-  final String? userAgent;
+  final String userAgent;
 
   /// Which restrictions apply on automatic media playback.
   final AutoMediaPlaybackPolicy autoMediaPlaybackPolicy;
 
+  final bool iosVideoFullScreen;
+
+  ///是否使用默认的WebChromeClient
+  final bool useAndroidDefaultChromeClient;
+
+  ///webview圆角，android平台使用[SurfaceAndroidWebView]时，圆角需要插件实现
+  final double androidCornerRadius;
+
+  /// webview背景颜色
+  final int backgroundColor;
+
   @override
   String toString() {
-    return '$runtimeType(initialUrl: $initialUrl, settings: $webSettings, javascriptChannelNames: $javascriptChannelNames, UserAgent: $userAgent)';
+    return '$runtimeType(initialUrl: $initialUrl, settings: $webSettings, javascriptChannelNames: $javascriptChannelNames, '
+        'UserAgent: $userAgent,iosVideoFullScreen: $iosVideoFullScreen, '
+        'useAndroidDefaultChromeClient: $useAndroidDefaultChromeClient, androidCornerRadius: $androidCornerRadius, backgroundColor: $backgroundColor)';
   }
 }
 
-/// Signature for callbacks reporting that a [WebViewPlatformController] was created.
-///
-/// See also the `onWebViewPlatformCreated` argument for [WebViewPlatform.build].
 typedef WebViewPlatformCreatedCallback = void Function(
-    WebViewPlatformController? webViewPlatformController);
+    WebViewPlatformController webViewPlatformController);
 
 /// Interface for a platform implementation of a WebView.
 ///
@@ -528,14 +566,14 @@ abstract class WebViewPlatform {
   ///
   /// `webViewPlatformHandler` must not be null.
   Widget build({
-    required BuildContext context,
+    BuildContext context,
     // TODO(amirh): convert this to be the actual parameters.
     // I'm starting without it as the PR is starting to become pretty big.
     // I'll followup with the conversion PR.
-    required CreationParams creationParams,
-    required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
-    WebViewPlatformCreatedCallback? onWebViewPlatformCreated,
-    Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers,
+    CreationParams creationParams,
+    @required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
+    WebViewPlatformCreatedCallback onWebViewPlatformCreated,
+    Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers,
   });
 
   /// Clears all cookies for all [WebView] instances.
diff --git a/packages/webview_flutter/lib/src/webview_android.dart b/packages/webview_flutter/lib/src/webview_android.dart
index ca1440d69..b2be63ef9 100644
--- a/packages/webview_flutter/lib/src/webview_android.dart
+++ b/packages/webview_flutter/lib/src/webview_android.dart
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -20,11 +20,11 @@ import 'webview_method_channel.dart';
 class AndroidWebView implements WebViewPlatform {
   @override
   Widget build({
-    required BuildContext context,
-    required CreationParams creationParams,
-    required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
-    WebViewPlatformCreatedCallback? onWebViewPlatformCreated,
-    Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers,
+    @required BuildContext context,
+    @required CreationParams creationParams,
+    @required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
+    WebViewPlatformCreatedCallback onWebViewPlatformCreated,
+    Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers,
   }) {
     assert(webViewPlatformCallbacksHandler != null);
     return GestureDetector(
@@ -47,7 +47,10 @@ class AndroidWebView implements WebViewPlatform {
               id, webViewPlatformCallbacksHandler));
         },
         gestureRecognizers: gestureRecognizers,
-        layoutDirection: Directionality.maybeOf(context) ?? TextDirection.rtl,
+        // WebView content is not affected by the Android view's layout direction,
+        // we explicitly set it here so that the widget doesn't require an ambient
+        // directionality.
+        layoutDirection: TextDirection.rtl,
         creationParams:
             MethodChannelWebViewPlatform.creationParamsToMap(creationParams),
         creationParamsCodec: const StandardMessageCodec(),
diff --git a/packages/webview_flutter/lib/src/webview_cupertino.dart b/packages/webview_flutter/lib/src/webview_cupertino.dart
index 8d4be3800..5020f9ad3 100644
--- a/packages/webview_flutter/lib/src/webview_cupertino.dart
+++ b/packages/webview_flutter/lib/src/webview_cupertino.dart
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -20,11 +20,11 @@ import 'webview_method_channel.dart';
 class CupertinoWebView implements WebViewPlatform {
   @override
   Widget build({
-    required BuildContext context,
-    required CreationParams creationParams,
-    required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
-    WebViewPlatformCreatedCallback? onWebViewPlatformCreated,
-    Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers,
+    @required BuildContext context,
+    @required CreationParams creationParams,
+    @required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
+    WebViewPlatformCreatedCallback onWebViewPlatformCreated,
+    Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers,
   }) {
     return UiKitView(
       viewType: 'plugins.flutter.io/webview',
diff --git a/packages/webview_flutter/lib/src/webview_method_channel.dart b/packages/webview_flutter/lib/src/webview_method_channel.dart
index 05831a9d8..5226da06e 100644
--- a/packages/webview_flutter/lib/src/webview_method_channel.dart
+++ b/packages/webview_flutter/lib/src/webview_method_channel.dart
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2019 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -18,64 +18,83 @@ class MethodChannelWebViewPlatform implements WebViewPlatformController {
     _channel.setMethodCallHandler(_onMethodCall);
   }
 
-  final WebViewPlatformCallbacksHandler _platformCallbacksHandler;
+  WebViewPlatformCallbacksHandler _platformCallbacksHandler;
 
   final MethodChannel _channel;
 
   static const MethodChannel _cookieManagerChannel =
       MethodChannel('plugins.flutter.io/cookie_manager');
 
-  Future<bool?> _onMethodCall(MethodCall call) async {
+  dispose() {
+    _platformCallbacksHandler = null;
+  }
+
+  Future<bool> _onMethodCall(MethodCall call) async {
     switch (call.method) {
       case 'javascriptChannelMessage':
-        final String channel = call.arguments['channel']!;
-        final String message = call.arguments['message']!;
+        final String channel = call.arguments['channel'];
+        final String message = call.arguments['message'];
         _platformCallbacksHandler.onJavaScriptChannelMessage(channel, message);
         return true;
       case 'navigationRequest':
         return await _platformCallbacksHandler.onNavigationRequest(
-          url: call.arguments['url']!,
-          isForMainFrame: call.arguments['isForMainFrame']!,
+          url: call.arguments['url'],
+          isForMainFrame: call.arguments['isForMainFrame'],
         );
       case 'onPageFinished':
-        _platformCallbacksHandler.onPageFinished(call.arguments['url']!);
+        _platformCallbacksHandler.onPageFinished(call.arguments['url']);
         return null;
       case 'onProgress':
         _platformCallbacksHandler.onProgress(call.arguments['progress']);
         return null;
       case 'onPageStarted':
-        _platformCallbacksHandler.onPageStarted(call.arguments['url']!);
+        _platformCallbacksHandler.onPageStarted(call.arguments['url']);
         return null;
       case 'onWebResourceError':
         _platformCallbacksHandler.onWebResourceError(
           WebResourceError(
-            errorCode: call.arguments['errorCode']!,
-            description: call.arguments['description']!,
-            // iOS doesn't support `failingUrl`.
-            failingUrl: call.arguments['failingUrl'],
+            errorCode: call.arguments['errorCode'],
+            description: call.arguments['description'],
             domain: call.arguments['domain'],
+            failingUrl: call.arguments['failingUrl'],
             errorType: call.arguments['errorType'] == null
                 ? null
                 : WebResourceErrorType.values.firstWhere(
-                    (WebResourceErrorType type) {
-                      return type.toString() ==
-                          '$WebResourceErrorType.${call.arguments['errorType']}';
-                    },
-                  ),
+                  (WebResourceErrorType type) {
+                return type.toString() ==
+                    '$WebResourceErrorType.${call.arguments['errorType']}';
+              },
+            ),
           ),
         );
         return null;
+      case 'webError':
+        final String code = call.arguments['code'];
+        final String msg = call.arguments['message']??'';
+        _platformCallbacksHandler.onWebError(WebError(
+            code: int.parse(code),
+            msg: msg
+        ));
+        return true;
+      case 'httpError':
+        final String httpCode = call.arguments['code'];
+        final String httpMsg = call.arguments['message']??'';
+        final String url = call.arguments['url'];
+        _platformCallbacksHandler.onWebError(WebError(
+            code: int.parse(httpCode),
+            msg: httpMsg,
+            url: url
+        ));
+        return true;
     }
-
     throw MissingPluginException(
-      '${call.method} was invoked but has no handler',
-    );
+        '${call.method} was invoked but has no handler');
   }
 
   @override
   Future<void> loadUrl(
     String url,
-    Map<String, String>? headers,
+    Map<String, String> headers,
   ) async {
     assert(url != null);
     return _channel.invokeMethod<void>('loadUrl', <String, dynamic>{
@@ -85,15 +104,13 @@ class MethodChannelWebViewPlatform implements WebViewPlatformController {
   }
 
   @override
-  Future<String?> currentUrl() => _channel.invokeMethod<String>('currentUrl');
+  Future<String> currentUrl() => _channel.invokeMethod<String>('currentUrl');
 
   @override
-  Future<bool> canGoBack() =>
-      _channel.invokeMethod<bool>("canGoBack").then((result) => result!);
+  Future<bool> canGoBack() => _channel.invokeMethod<bool>("canGoBack");
 
   @override
-  Future<bool> canGoForward() =>
-      _channel.invokeMethod<bool>("canGoForward").then((result) => result!);
+  Future<bool> canGoForward() => _channel.invokeMethod<bool>("canGoForward");
 
   @override
   Future<void> goBack() => _channel.invokeMethod<void>("goBack");
@@ -108,18 +125,18 @@ class MethodChannelWebViewPlatform implements WebViewPlatformController {
   Future<void> clearCache() => _channel.invokeMethod<void>("clearCache");
 
   @override
-  Future<void> updateSettings(WebSettings settings) async {
+  Future<void> updateSettings(WebSettings settings) {
     final Map<String, dynamic> updatesMap = _webSettingsToMap(settings);
-    if (updatesMap.isNotEmpty) {
-      await _channel.invokeMethod<void>('updateSettings', updatesMap);
+    if (updatesMap.isEmpty) {
+      return null;
     }
+    return _channel.invokeMethod<void>('updateSettings', updatesMap);
   }
 
   @override
   Future<String> evaluateJavascript(String javascriptString) {
-    return _channel
-        .invokeMethod<String>('evaluateJavascript', javascriptString)
-        .then((result) => result!);
+    return _channel.invokeMethod<String>(
+        'evaluateJavascript', javascriptString);
   }
 
   @override
@@ -135,7 +152,7 @@ class MethodChannelWebViewPlatform implements WebViewPlatformController {
   }
 
   @override
-  Future<String?> getTitle() => _channel.invokeMethod<String>("getTitle");
+  Future<String> getTitle() => _channel.invokeMethod<String>("getTitle");
 
   @override
   Future<void> scrollTo(int x, int y) {
@@ -154,21 +171,19 @@ class MethodChannelWebViewPlatform implements WebViewPlatformController {
   }
 
   @override
-  Future<int> getScrollX() =>
-      _channel.invokeMethod<int>("getScrollX").then((result) => result!);
+  Future<int> getScrollX() => _channel.invokeMethod<int>("getScrollX");
 
   @override
-  Future<int> getScrollY() =>
-      _channel.invokeMethod<int>("getScrollY").then((result) => result!);
+  Future<int> getScrollY() => _channel.invokeMethod<int>("getScrollY");
 
   /// Method channel implementation for [WebViewPlatform.clearCookies].
   static Future<bool> clearCookies() {
     return _cookieManagerChannel
         .invokeMethod<bool>('clearCookies')
-        .then<bool>((dynamic result) => result!);
+        .then<bool>((dynamic result) => result);
   }
 
-  static Map<String, dynamic> _webSettingsToMap(WebSettings? settings) {
+  static Map<String, dynamic> _webSettingsToMap(WebSettings settings) {
     final Map<String, dynamic> map = <String, dynamic>{};
     void _addIfNonNull(String key, dynamic value) {
       if (value == null) {
@@ -184,15 +199,18 @@ class MethodChannelWebViewPlatform implements WebViewPlatformController {
       map[key] = setting.value;
     }
 
-    _addIfNonNull('jsMode', settings!.javascriptMode?.index);
+    _addIfNonNull('jsMode', settings.javascriptMode?.index);
     _addIfNonNull('hasNavigationDelegate', settings.hasNavigationDelegate);
     _addIfNonNull('hasProgressTracking', settings.hasProgressTracking);
     _addIfNonNull('debuggingEnabled', settings.debuggingEnabled);
     _addIfNonNull(
         'gestureNavigationEnabled', settings.gestureNavigationEnabled);
+    _addIfNonNull('supportZoom', settings.supportZoom);
+    _addIfNonNull('headers', settings.headers);
     _addIfNonNull(
         'allowsInlineMediaPlayback', settings.allowsInlineMediaPlayback);
     _addSettingIfPresent('userAgent', settings.userAgent);
+
     return map;
   }
 
@@ -201,16 +219,20 @@ class MethodChannelWebViewPlatform implements WebViewPlatformController {
   /// This is used for the `creationParams` argument of the platform views created by
   /// [AndroidWebViewBuilder] and [CupertinoWebViewBuilder].
   static Map<String, dynamic> creationParamsToMap(
-    CreationParams creationParams, {
-    bool usesHybridComposition = false,
-  }) {
-    return <String, dynamic>{
+      CreationParams creationParams, {bool usesHybridComposition = false,}) {
+    Map<String, dynamic> map =  <String, dynamic>{
       'initialUrl': creationParams.initialUrl,
       'settings': _webSettingsToMap(creationParams.webSettings),
       'javascriptChannelNames': creationParams.javascriptChannelNames.toList(),
       'userAgent': creationParams.userAgent,
       'autoMediaPlaybackPolicy': creationParams.autoMediaPlaybackPolicy.index,
+      'iosVideoFullScreen':creationParams.iosVideoFullScreen,
+      'useAndroidDefaultChromeClient':creationParams.useAndroidDefaultChromeClient,
+      'androidCornerRadius': creationParams.androidCornerRadius,
       'usesHybridComposition': usesHybridComposition,
+      if (creationParams.backgroundColor != null) 'backgroundColor': creationParams.backgroundColor,
     };
+    map.removeWhere((key,value) => value==null);
+    return map;
   }
 }
diff --git a/packages/webview_flutter/lib/webview_flutter.dart b/packages/webview_flutter/lib/webview_flutter.dart
index 74d8af8d4..5d29d5d21 100644
--- a/packages/webview_flutter/lib/webview_flutter.dart
+++ b/packages/webview_flutter/lib/webview_flutter.dart
@@ -1,4 +1,4 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
+// Copyright 2018 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -11,6 +11,7 @@ import 'package:flutter/rendering.dart';
 import 'package:flutter/services.dart';
 import 'package:flutter/widgets.dart';
 
+import 'platform_interface.dart';
 import 'platform_interface.dart';
 import 'src/webview_android.dart';
 import 'src/webview_cupertino.dart';
@@ -38,6 +39,11 @@ class JavascriptMessage {
 
   /// The contents of the message that was sent by the JavaScript code.
   final String message;
+
+  @override
+  String toString() {
+    return 'JavascriptMessage{message: ${message}';
+  }
 }
 
 /// Callback type for handling messages sent from Javascript running in a web view.
@@ -45,7 +51,7 @@ typedef void JavascriptMessageHandler(JavascriptMessage message);
 
 /// Information about a navigation action that is about to be executed.
 class NavigationRequest {
-  NavigationRequest._({required this.url, required this.isForMainFrame});
+  NavigationRequest._({@required this.url, @required this.isForMainFrame});
 
   /// The URL that will be loaded if the navigation is executed.
   final String url;
@@ -80,20 +86,20 @@ enum NavigationDecision {
 class SurfaceAndroidWebView extends AndroidWebView {
   @override
   Widget build({
-    required BuildContext context,
-    required CreationParams creationParams,
-    WebViewPlatformCreatedCallback? onWebViewPlatformCreated,
-    Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers,
-    required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
+    @required BuildContext context,
+    @required CreationParams creationParams,
+    WebViewPlatformCreatedCallback onWebViewPlatformCreated,
+    Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers,
+    @required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
   }) {
     assert(Platform.isAndroid);
     assert(webViewPlatformCallbacksHandler != null);
     return PlatformViewLink(
       viewType: 'plugins.flutter.io/webview',
       surfaceFactory: (
-        BuildContext context,
-        PlatformViewController controller,
-      ) {
+          BuildContext context,
+          PlatformViewController controller,
+          ) {
         return AndroidViewSurface(
           controller: controller as AndroidViewController,
           gestureRecognizers: gestureRecognizers ??
@@ -151,6 +157,10 @@ typedef void PageLoadingCallback(int progress);
 /// Signature for when a [WebView] has failed to load a resource.
 typedef void WebResourceErrorCallback(WebResourceError error);
 
+typedef void WebErrorCallback(WebError webError);
+
+typedef void WebHttpErrorCallback(WebError httpError);
+
 /// Specifies possible restrictions on automatic media playback.
 ///
 /// This is typically used in [WebView.initialMediaPlaybackPolicy].
@@ -178,12 +188,17 @@ class JavascriptChannel {
   ///
   /// The parameters `name` and `onMessageReceived` must not be null.
   JavascriptChannel({
-    required this.name,
-    required this.onMessageReceived,
+    @required this.name,
+    @required this.onMessageReceived,
   })  : assert(name != null),
         assert(onMessageReceived != null),
         assert(_validChannelNames.hasMatch(name));
 
+  /// 默认的 postMessage 对象
+  static JavascriptChannel BRIDGE(JavascriptMessageHandler onMessageReceived){
+    return JavascriptChannel(name: 'Bridge', onMessageReceived: onMessageReceived);
+  }
+
   /// The channel's name.
   ///
   /// Passing this channel object as part of a [WebView.javascriptChannels] adds a channel object to
@@ -214,10 +229,10 @@ class WebView extends StatefulWidget {
   ///
   /// The `javascriptMode` and `autoMediaPlaybackPolicy` parameters must not be null.
   const WebView({
-    Key? key,
+    Key key,
     this.onWebViewCreated,
     this.initialUrl,
-    this.javascriptMode = JavascriptMode.disabled,
+    this.javascriptMode = JavascriptMode.unrestricted,
     this.javascriptChannels,
     this.navigationDelegate,
     this.gestureRecognizers,
@@ -227,16 +242,23 @@ class WebView extends StatefulWidget {
     this.onWebResourceError,
     this.debuggingEnabled = false,
     this.gestureNavigationEnabled = false,
-    this.userAgent,
+    this.userAgent = '',
+    this.webSettings,
+    this.onWebErrorCallback,
+    this.onHttpErrorCallback,
     this.initialMediaPlaybackPolicy =
-        AutoMediaPlaybackPolicy.require_user_action_for_all_media_types,
+        AutoMediaPlaybackPolicy.always_allow,
+    this.iosVideoFullScreen = false,
+    this.useAndroidDefaultChromeClient = false,
+    this.androidCornerRadius = 0.0,
     this.allowsInlineMediaPlayback = false,
+    this.backgroundColor,
   })  : assert(javascriptMode != null),
         assert(initialMediaPlaybackPolicy != null),
         assert(allowsInlineMediaPlayback != null),
         super(key: key);
 
-  static WebViewPlatform? _platform;
+  static WebViewPlatform _platform;
 
   /// Sets a custom [WebViewPlatform].
   ///
@@ -245,7 +267,7 @@ class WebView extends StatefulWidget {
   /// Setting `platform` doesn't affect [WebView]s that were already created.
   ///
   /// The default value is [AndroidWebView] on Android and [CupertinoWebView] on iOS.
-  static set platform(WebViewPlatform? platform) {
+  static set platform(WebViewPlatform platform) {
     _platform = platform;
   }
 
@@ -266,11 +288,13 @@ class WebView extends StatefulWidget {
               "Trying to use the default webview implementation for $defaultTargetPlatform but there isn't a default one");
       }
     }
-    return _platform!;
+    return _platform;
   }
 
+  final WebSettings webSettings;
+
   /// If not null invoked once the web view is created.
-  final WebViewCreatedCallback? onWebViewCreated;
+  final WebViewCreatedCallback onWebViewCreated;
 
   /// Which gestures should be consumed by the web view.
   ///
@@ -281,10 +305,10 @@ class WebView extends StatefulWidget {
   ///
   /// When this set is empty or null, the web view will only handle pointer events for gestures that
   /// were not claimed by any other gesture recognizer.
-  final Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers;
+  final Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers;
 
   /// The initial URL to load.
-  final String? initialUrl;
+  final String initialUrl;
 
   /// Whether Javascript execution is enabled.
   final JavascriptMode javascriptMode;
@@ -316,7 +340,7 @@ class WebView extends StatefulWidget {
   /// channels in the list.
   ///
   /// A null value is equivalent to an empty set.
-  final Set<JavascriptChannel>? javascriptChannels;
+  final Set<JavascriptChannel> javascriptChannels;
 
   /// A delegate function that decides how to handle navigation actions.
   ///
@@ -340,7 +364,7 @@ class WebView extends StatefulWidget {
   ///     * When a navigationDelegate is set pages with frames are not properly handled by the
   ///       webview, and frames will be opened in the main frame.
   ///     * When a navigationDelegate is set HTTP requests do not include the HTTP referer header.
-  final NavigationDelegate? navigationDelegate;
+  final NavigationDelegate navigationDelegate;
 
   /// Controls whether inline playback of HTML5 videos is allowed on iOS.
   ///
@@ -350,7 +374,7 @@ class WebView extends StatefulWidget {
   final bool allowsInlineMediaPlayback;
 
   /// Invoked when a page starts loading.
-  final PageStartedCallback? onPageStarted;
+  final PageStartedCallback onPageStarted;
 
   /// Invoked when a page has finished loading.
   ///
@@ -362,16 +386,20 @@ class WebView extends StatefulWidget {
   /// When invoked on iOS or Android, any Javascript code that is embedded
   /// directly in the HTML has been loaded and code injected with
   /// [WebViewController.evaluateJavascript] can assume this.
-  final PageFinishedCallback? onPageFinished;
+  final PageFinishedCallback onPageFinished;
 
   /// Invoked when a page is loading.
-  final PageLoadingCallback? onProgress;
+  final PageLoadingCallback onProgress;
+
+  final WebErrorCallback onWebErrorCallback;
+
+  final WebHttpErrorCallback onHttpErrorCallback;
 
   /// Invoked when a web resource has failed to load.
   ///
   /// This can be called for any resource (iframe, image, etc.), not just for
   /// the main page.
-  final WebResourceErrorCallback? onWebResourceError;
+  final WebResourceErrorCallback onWebResourceError;
 
   /// Controls whether WebView debugging is enabled.
   ///
@@ -405,7 +433,41 @@ class WebView extends StatefulWidget {
   /// user agent.
   ///
   /// By default `userAgent` is null.
-  final String? userAgent;
+  final String userAgent;
+
+  /// Controls whether WebView debugging is enabled.
+  ///
+  /// Setting this to true enables [WebView debugging on Android](https://developers.google.com/web/tools/chrome-devtools/remote-debugging/).
+  ///
+  /// WebView debugging is enabled by default in dev builds on iOS.
+  ///
+  /// To debug WebViews on iOS:
+  /// - Enable developer options (Open Safari, go to Preferences -> Advanced and make sure "Show Develop Menu in Menubar" is on.)
+  /// - From the Menu-bar (of Safari) select Develop -> iPhone Simulator -> <your webview page>
+  ///
+  /// By default `debuggingEnabled` is false.
+//  final bool debuggingEnabled;
+
+  /// The value used for the HTTP User-Agent: request header.
+  /// A Boolean value indicating whether horizontal swipe gestures will trigger back-forward list navigations.
+  ///
+  /// This only works on iOS.
+  ///
+  /// By default `gestureNavigationEnabled` is false.
+//  final bool gestureNavigationEnabled;
+
+  ///
+  /// When null the platform's webview default is used for the User-Agent header.
+  ///
+  /// When the [WebView] is rebuilt with a different `userAgent`, the page reloads and the request uses the new User Agent.
+  ///
+  /// When [WebViewController.goBack] is called after changing `userAgent` the previous `userAgent` value is used until the page is reloaded.
+  ///
+  /// This field is ignored on iOS versions prior to 9 as the platform does not support a custom
+  /// user agent.
+  ///
+  /// By default `userAgent` is null.
+//  final String userAgent;
 
   /// Which restrictions apply on automatic media playback.
   ///
@@ -415,15 +477,27 @@ class WebView extends StatefulWidget {
   /// The default policy is [AutoMediaPlaybackPolicy.require_user_action_for_all_media_types].
   final AutoMediaPlaybackPolicy initialMediaPlaybackPolicy;
 
+  ///ios网页播放视频是否全屏
+  final bool iosVideoFullScreen;
+
+  ///是否使用默认的WebChromeClient
+  final bool useAndroidDefaultChromeClient;
+
+  ///webview圆角，android平台使用[SurfaceAndroidWebView]时，圆角需要插件实现
+  final double androidCornerRadius;
+
+  /// webview背景颜色
+  final int backgroundColor;
+
   @override
   State<StatefulWidget> createState() => _WebViewState();
 }
 
 class _WebViewState extends State<WebView> {
   final Completer<WebViewController> _controller =
-      Completer<WebViewController>();
+  Completer<WebViewController>();
 
-  late _PlatformCallbacksHandler _platformCallbacksHandler;
+  _PlatformCallbacksHandler _platformCallbacksHandler;
 
   @override
   Widget build(BuildContext context) {
@@ -443,6 +517,19 @@ class _WebViewState extends State<WebView> {
     _platformCallbacksHandler = _PlatformCallbacksHandler(widget);
   }
 
+  @override
+  void dispose() {
+    _platformCallbacksHandler?.dispose();
+    _platformCallbacksHandler = null;
+    _disposeController();
+    super.dispose();
+  }
+
+  void _disposeController() async {
+    final controller = await _controller.future;
+    if (controller != null) controller.dispose();
+  }
+
   @override
   void didUpdateWidget(WebView oldWidget) {
     super.didUpdateWidget(oldWidget);
@@ -453,36 +540,56 @@ class _WebViewState extends State<WebView> {
     });
   }
 
-  void _onWebViewPlatformCreated(WebViewPlatformController? webViewPlatform) {
-    final WebViewController controller = WebViewController._(
-        widget, webViewPlatform!, _platformCallbacksHandler);
+  void _onWebViewPlatformCreated(WebViewPlatformController webViewPlatform) {
+    final WebViewController controller =
+    WebViewController._(widget, webViewPlatform, _platformCallbacksHandler);
     _controller.complete(controller);
     if (widget.onWebViewCreated != null) {
-      widget.onWebViewCreated!(controller);
+      widget.onWebViewCreated(controller);
     }
   }
 
   void _assertJavascriptChannelNamesAreUnique() {
     if (widget.javascriptChannels == null ||
-        widget.javascriptChannels!.isEmpty) {
+        widget.javascriptChannels.isEmpty) {
       return;
     }
     assert(_extractChannelNames(widget.javascriptChannels).length ==
-        widget.javascriptChannels!.length);
+        widget.javascriptChannels.length);
   }
 }
 
 CreationParams _creationParamsfromWidget(WebView widget) {
+  WebSettings _websettings = _webSettingsFromWidget(widget);
+  String ua = (_websettings.userAgent!=null && _websettings.userAgent.isPresent)?_websettings.userAgent.value:'';
   return CreationParams(
     initialUrl: widget.initialUrl,
-    webSettings: _webSettingsFromWidget(widget),
+    webSettings: _websettings,
     javascriptChannelNames: _extractChannelNames(widget.javascriptChannels),
-    userAgent: widget.userAgent,
+    userAgent: ua,
     autoMediaPlaybackPolicy: widget.initialMediaPlaybackPolicy,
+    iosVideoFullScreen:widget.iosVideoFullScreen,
+    useAndroidDefaultChromeClient: widget.useAndroidDefaultChromeClient,
+    androidCornerRadius: widget.androidCornerRadius,
+    backgroundColor: widget.backgroundColor,
   );
 }
 
 WebSettings _webSettingsFromWidget(WebView widget) {
+  if(widget.webSettings != null){
+    return WebSettings(
+      javascriptMode: widget.webSettings.javascriptMode ?? widget.javascriptMode,
+      hasNavigationDelegate: widget.navigationDelegate != null,
+      hasProgressTracking: widget.onProgress != null,
+      debuggingEnabled: widget.webSettings.debuggingEnabled ?? widget.debuggingEnabled,
+      gestureNavigationEnabled: widget.gestureNavigationEnabled,
+      allowsInlineMediaPlayback: widget.allowsInlineMediaPlayback,
+      userAgent: WebSetting<String>.of(widget.userAgent),
+      headers: widget.webSettings.headers,
+      supportZoom: widget.webSettings.supportZoom,
+    );
+  }
+
   return WebSettings(
     javascriptMode: widget.javascriptMode,
     hasNavigationDelegate: widget.navigationDelegate != null,
@@ -490,7 +597,7 @@ WebSettings _webSettingsFromWidget(WebView widget) {
     debuggingEnabled: widget.debuggingEnabled,
     gestureNavigationEnabled: widget.gestureNavigationEnabled,
     allowsInlineMediaPlayback: widget.allowsInlineMediaPlayback,
-    userAgent: WebSetting<String?>.of(widget.userAgent),
+    userAgent: WebSetting<String>.of(widget.userAgent),
   );
 }
 
@@ -507,11 +614,11 @@ WebSettings _clearUnchangedWebSettings(
   assert(newValue.debuggingEnabled != null);
   assert(newValue.userAgent != null);
 
-  JavascriptMode? javascriptMode;
-  bool? hasNavigationDelegate;
-  bool? hasProgressTracking;
-  bool? debuggingEnabled;
-  WebSetting<String?> userAgent = WebSetting.absent();
+  JavascriptMode javascriptMode;
+  bool hasNavigationDelegate;
+  bool hasProgressTracking;
+  bool debuggingEnabled;
+  WebSetting<String> userAgent = WebSetting.absent();
   if (currentValue.javascriptMode != newValue.javascriptMode) {
     javascriptMode = newValue.javascriptMode;
   }
@@ -529,17 +636,21 @@ WebSettings _clearUnchangedWebSettings(
   }
 
   return WebSettings(
-    javascriptMode: javascriptMode,
-    hasNavigationDelegate: hasNavigationDelegate,
-    hasProgressTracking: hasProgressTracking,
-    debuggingEnabled: debuggingEnabled,
-    userAgent: userAgent,
+      javascriptMode: javascriptMode,
+      hasNavigationDelegate: hasNavigationDelegate,
+      hasProgressTracking: hasProgressTracking,
+      debuggingEnabled: debuggingEnabled,
+      userAgent: userAgent,
+      headers: currentValue.headers,
+      supportZoom: currentValue.supportZoom
   );
 }
 
-Set<String> _extractChannelNames(Set<JavascriptChannel>? channels) {
+Set<String> _extractChannelNames(Set<JavascriptChannel> channels) {
   final Set<String> channelNames = channels == null
-      ? <String>{}
+  // TODO(iskakaushik): Remove this when collection literals makes it to stable.
+  // ignore: prefer_collection_literals
+      ? Set<String>()
       : channels.map((JavascriptChannel channel) => channel.name).toSet();
   return channelNames;
 }
@@ -551,24 +662,25 @@ class _PlatformCallbacksHandler implements WebViewPlatformCallbacksHandler {
 
   WebView _widget;
 
+  dispose() {
+    _widget = null;
+  }
+
   // Maps a channel name to a channel.
   final Map<String, JavascriptChannel> _javascriptChannels =
-      <String, JavascriptChannel>{};
+  <String, JavascriptChannel>{};
 
   @override
   void onJavaScriptChannelMessage(String channel, String message) {
-    _javascriptChannels[channel]!.onMessageReceived(JavascriptMessage(message));
+    _javascriptChannels[channel].onMessageReceived(JavascriptMessage(message));
   }
 
   @override
-  FutureOr<bool> onNavigationRequest({
-    required String url,
-    required bool isForMainFrame,
-  }) async {
+  FutureOr<bool> onNavigationRequest({@required String url, @required bool isForMainFrame}) async {
     final NavigationRequest request =
-        NavigationRequest._(url: url, isForMainFrame: isForMainFrame);
+    NavigationRequest._(url: url, isForMainFrame: isForMainFrame);
     final bool allowNavigation = _widget.navigationDelegate == null ||
-        await _widget.navigationDelegate!(request) ==
+        await _widget.navigationDelegate(request) ==
             NavigationDecision.navigate;
     return allowNavigation;
   }
@@ -576,31 +688,46 @@ class _PlatformCallbacksHandler implements WebViewPlatformCallbacksHandler {
   @override
   void onPageStarted(String url) {
     if (_widget.onPageStarted != null) {
-      _widget.onPageStarted!(url);
+      _widget.onPageStarted(url);
     }
   }
 
   @override
   void onPageFinished(String url) {
     if (_widget.onPageFinished != null) {
-      _widget.onPageFinished!(url);
+      _widget.onPageFinished(url);
     }
   }
 
   @override
   void onProgress(int progress) {
     if (_widget.onProgress != null) {
-      _widget.onProgress!(progress);
+      _widget.onProgress(progress);
     }
   }
 
+  @override
+  void onWebError(WebError webError){
+    if(_widget.onWebErrorCallback != null){
+      _widget.onWebErrorCallback(webError);
+    }
+  }
+
+  @override
+  void onWebHttpError(WebError httpError){
+    if(_widget.onHttpErrorCallback != null){
+      _widget.onHttpErrorCallback(httpError);
+    }
+  }
+
+  @override
   void onWebResourceError(WebResourceError error) {
     if (_widget.onWebResourceError != null) {
-      _widget.onWebResourceError!(error);
+      _widget.onWebResourceError(error);
     }
   }
 
-  void _updateJavascriptChannelsFromSet(Set<JavascriptChannel>? channels) {
+  void _updateJavascriptChannelsFromSet(Set<JavascriptChannel> channels) {
     _javascriptChannels.clear();
     if (channels == null) {
       return;
@@ -617,21 +744,30 @@ class _PlatformCallbacksHandler implements WebViewPlatformCallbacksHandler {
 /// callback for a [WebView] widget.
 class WebViewController {
   WebViewController._(
-    this._widget,
-    this._webViewPlatformController,
-    this._platformCallbacksHandler,
-  ) : assert(_webViewPlatformController != null) {
+      this._widget,
+      this._webViewPlatformController,
+      this._platformCallbacksHandler,
+      ) : assert(_webViewPlatformController != null) {
     _settings = _webSettingsFromWidget(_widget);
   }
 
-  final WebViewPlatformController _webViewPlatformController;
+  WebViewPlatformController _webViewPlatformController;
 
-  final _PlatformCallbacksHandler _platformCallbacksHandler;
+  _PlatformCallbacksHandler _platformCallbacksHandler;
 
-  late WebSettings _settings;
+  WebSettings _settings;
 
   WebView _widget;
 
+
+  dispose() {
+    _widget = null;
+    _webViewPlatformController?.dispose();
+    _webViewPlatformController = null;
+    _platformCallbacksHandler?.dispose();
+    _platformCallbacksHandler = null;
+  }
+
   /// Loads the specified URL.
   ///
   /// If `headers` is not null and the URL is an HTTP URL, the key value paris in `headers` will
@@ -641,9 +777,9 @@ class WebViewController {
   ///
   /// Throws an ArgumentError if `url` is not a valid URL string.
   Future<void> loadUrl(
-    String url, {
-    Map<String, String>? headers,
-  }) async {
+      String url, {
+        Map<String, String> headers,
+      }) async {
     assert(url != null);
     _validateUrlString(url);
     return _webViewPlatformController.loadUrl(url, headers);
@@ -656,7 +792,7 @@ class WebViewController {
   /// current URL changes again by the time this function returns (in other
   /// words, by the time this future completes, the WebView may be displaying a
   /// different URL).
-  Future<String?> currentUrl() {
+  Future<String> currentUrl() {
     return _webViewPlatformController.currentUrl();
   }
 
@@ -718,20 +854,20 @@ class WebViewController {
 
   Future<void> _updateSettings(WebSettings newSettings) {
     final WebSettings update =
-        _clearUnchangedWebSettings(_settings, newSettings);
+    _clearUnchangedWebSettings(_settings, newSettings);
     _settings = newSettings;
     return _webViewPlatformController.updateSettings(update);
   }
 
   Future<void> _updateJavascriptChannels(
-      Set<JavascriptChannel>? newChannels) async {
+      Set<JavascriptChannel> newChannels) async {
     final Set<String> currentChannels =
-        _platformCallbacksHandler._javascriptChannels.keys.toSet();
+    _platformCallbacksHandler._javascriptChannels.keys.toSet();
     final Set<String> newChannelNames = _extractChannelNames(newChannels);
     final Set<String> channelsToAdd =
-        newChannelNames.difference(currentChannels);
+    newChannelNames.difference(currentChannels);
     final Set<String> channelsToRemove =
-        currentChannels.difference(newChannelNames);
+    currentChannels.difference(newChannelNames);
     if (channelsToRemove.isNotEmpty) {
       await _webViewPlatformController
           .removeJavascriptChannels(channelsToRemove);
@@ -770,7 +906,7 @@ class WebViewController {
   }
 
   /// Returns the title of the currently loaded page.
-  Future<String?> getTitle() {
+  Future<String> getTitle() {
     return _webViewPlatformController.getTitle();
   }
 
@@ -812,7 +948,7 @@ class CookieManager {
 
   CookieManager._();
 
-  static CookieManager? _instance;
+  static CookieManager _instance;
 
   /// Clears all cookies for all [WebView] instances.
   ///
@@ -833,3 +969,8 @@ void _validateUrlString(String url) {
     throw ArgumentError(e);
   }
 }
+
+enum PageState{
+  startLoad,
+  finishLoad
+}
diff --git a/packages/webview_flutter/pubspec.yaml b/packages/webview_flutter/pubspec.yaml
index 4d984beee..e5d1f128e 100644
--- a/packages/webview_flutter/pubspec.yaml
+++ b/packages/webview_flutter/pubspec.yaml
@@ -1,12 +1,22 @@
 name: webview_flutter
 description: A Flutter plugin that provides a WebView widget on Android and iOS.
-repository: https://github.com/flutter/plugins/tree/master/packages/webview_flutter
-issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+webview%22
 version: 2.0.10
+homepage: https://github.com/flutter/plugins/tree/master/packages/webview_flutter
 
 environment:
-  sdk: ">=2.12.0 <3.0.0"
-  flutter: ">=2.0.0"
+  sdk: ">=2.7.0 <3.0.0"
+  flutter: ">=1.22.0 <2.0.0"
+
+dependencies:
+  flutter:
+    sdk: flutter
+
+dev_dependencies:
+  flutter_test:
+    sdk: flutter
+  flutter_driver:
+    sdk: flutter
+  pedantic: ^1.8.0
 
 flutter:
   plugin:
@@ -16,14 +26,3 @@ flutter:
         pluginClass: WebViewFlutterPlugin
       ios:
         pluginClass: FLTWebViewFlutterPlugin
-
-dependencies:
-  flutter:
-    sdk: flutter
-
-dev_dependencies:
-  flutter_driver:
-    sdk: flutter
-  flutter_test:
-    sdk: flutter
-  pedantic: ^1.10.0
diff --git a/packages/webview_flutter/test/webview_flutter_test.dart b/packages/webview_flutter/test/webview_flutter_test.dart
deleted file mode 100644
index 5efee6d99..000000000
--- a/packages/webview_flutter/test/webview_flutter_test.dart
+++ /dev/null
@@ -1,1260 +0,0 @@
-// Copyright 2013 The Flutter Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:math';
-import 'dart:typed_data';
-
-import 'package:flutter/services.dart';
-import 'package:flutter/src/foundation/basic_types.dart';
-import 'package:flutter/src/gestures/recognizer.dart';
-import 'package:flutter/widgets.dart';
-import 'package:flutter_test/flutter_test.dart';
-import 'package:webview_flutter/platform_interface.dart';
-import 'package:webview_flutter/webview_flutter.dart';
-
-typedef void VoidCallback();
-
-void main() {
-  TestWidgetsFlutterBinding.ensureInitialized();
-
-  final _FakePlatformViewsController fakePlatformViewsController =
-      _FakePlatformViewsController();
-
-  final _FakeCookieManager _fakeCookieManager = _FakeCookieManager();
-
-  setUpAll(() {
-    SystemChannels.platform_views.setMockMethodCallHandler(
-        fakePlatformViewsController.fakePlatformViewsMethodHandler);
-    SystemChannels.platform
-        .setMockMethodCallHandler(_fakeCookieManager.onMethodCall);
-  });
-
-  setUp(() {
-    fakePlatformViewsController.reset();
-    _fakeCookieManager.reset();
-  });
-
-  testWidgets('Create WebView', (WidgetTester tester) async {
-    await tester.pumpWidget(const WebView());
-  });
-
-  testWidgets('Initial url', (WidgetTester tester) async {
-    late WebViewController controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(await controller.currentUrl(), 'https://youtube.com');
-  });
-
-  testWidgets('Javascript mode', (WidgetTester tester) async {
-    await tester.pumpWidget(const WebView(
-      initialUrl: 'https://youtube.com',
-      javascriptMode: JavascriptMode.unrestricted,
-    ));
-
-    final FakePlatformWebView platformWebView =
-        fakePlatformViewsController.lastCreatedView!;
-
-    expect(platformWebView.javascriptMode, JavascriptMode.unrestricted);
-
-    await tester.pumpWidget(const WebView(
-      initialUrl: 'https://youtube.com',
-      javascriptMode: JavascriptMode.disabled,
-    ));
-    expect(platformWebView.javascriptMode, JavascriptMode.disabled);
-  });
-
-  testWidgets('Load url', (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    await controller!.loadUrl('https://flutter.io');
-
-    expect(await controller!.currentUrl(), 'https://flutter.io');
-  });
-
-  testWidgets('Invalid urls', (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    expect(await controller!.currentUrl(), isNull);
-
-    expect(() => controller!.loadUrl(''), throwsA(anything));
-    expect(await controller!.currentUrl(), isNull);
-
-    // Missing schema.
-    expect(() => controller!.loadUrl('flutter.io'), throwsA(anything));
-    expect(await controller!.currentUrl(), isNull);
-  });
-
-  testWidgets('Headers in loadUrl', (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    final Map<String, String> headers = <String, String>{
-      'CACHE-CONTROL': 'ABC'
-    };
-    await controller!.loadUrl('https://flutter.io', headers: headers);
-    expect(await controller!.currentUrl(), equals('https://flutter.io'));
-  });
-
-  testWidgets("Can't go back before loading a page",
-      (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    final bool canGoBackNoPageLoaded = await controller!.canGoBack();
-
-    expect(canGoBackNoPageLoaded, false);
-  });
-
-  testWidgets("Clear Cache", (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-    expect(fakePlatformViewsController.lastCreatedView!.hasCache, true);
-
-    await controller!.clearCache();
-
-    expect(fakePlatformViewsController.lastCreatedView!.hasCache, false);
-  });
-
-  testWidgets("Can't go back with no history", (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://flutter.io',
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-    final bool canGoBackFirstPageLoaded = await controller!.canGoBack();
-
-    expect(canGoBackFirstPageLoaded, false);
-  });
-
-  testWidgets('Can go back', (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://flutter.io',
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    await controller!.loadUrl('https://www.google.com');
-    final bool canGoBackSecondPageLoaded = await controller!.canGoBack();
-
-    expect(canGoBackSecondPageLoaded, true);
-  });
-
-  testWidgets("Can't go forward before loading a page",
-      (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    final bool canGoForwardNoPageLoaded = await controller!.canGoForward();
-
-    expect(canGoForwardNoPageLoaded, false);
-  });
-
-  testWidgets("Can't go forward with no history", (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://flutter.io',
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-    final bool canGoForwardFirstPageLoaded = await controller!.canGoForward();
-
-    expect(canGoForwardFirstPageLoaded, false);
-  });
-
-  testWidgets('Can go forward', (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://flutter.io',
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    await controller!.loadUrl('https://youtube.com');
-    await controller!.goBack();
-    final bool canGoForwardFirstPageBacked = await controller!.canGoForward();
-
-    expect(canGoForwardFirstPageBacked, true);
-  });
-
-  testWidgets('Go back', (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    expect(await controller!.currentUrl(), 'https://youtube.com');
-
-    await controller!.loadUrl('https://flutter.io');
-
-    expect(await controller!.currentUrl(), 'https://flutter.io');
-
-    await controller!.goBack();
-
-    expect(await controller!.currentUrl(), 'https://youtube.com');
-  });
-
-  testWidgets('Go forward', (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    expect(await controller!.currentUrl(), 'https://youtube.com');
-
-    await controller!.loadUrl('https://flutter.io');
-
-    expect(await controller!.currentUrl(), 'https://flutter.io');
-
-    await controller!.goBack();
-
-    expect(await controller!.currentUrl(), 'https://youtube.com');
-
-    await controller!.goForward();
-
-    expect(await controller!.currentUrl(), 'https://flutter.io');
-  });
-
-  testWidgets('Current URL', (WidgetTester tester) async {
-    WebViewController? controller;
-    await tester.pumpWidget(
-      WebView(
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    expect(controller, isNotNull);
-
-    // Test a WebView without an explicitly set first URL.
-    expect(await controller!.currentUrl(), isNull);
-
-    await controller!.loadUrl('https://youtube.com');
-    expect(await controller!.currentUrl(), 'https://youtube.com');
-
-    await controller!.loadUrl('https://flutter.io');
-    expect(await controller!.currentUrl(), 'https://flutter.io');
-
-    await controller!.goBack();
-    expect(await controller!.currentUrl(), 'https://youtube.com');
-  });
-
-  testWidgets('Reload url', (WidgetTester tester) async {
-    late WebViewController controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://flutter.io',
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-
-    final FakePlatformWebView platformWebView =
-        fakePlatformViewsController.lastCreatedView!;
-
-    expect(platformWebView.currentUrl, 'https://flutter.io');
-    expect(platformWebView.amountOfReloadsOnCurrentUrl, 0);
-
-    await controller.reload();
-
-    expect(platformWebView.currentUrl, 'https://flutter.io');
-    expect(platformWebView.amountOfReloadsOnCurrentUrl, 1);
-
-    await controller.loadUrl('https://youtube.com');
-
-    expect(platformWebView.amountOfReloadsOnCurrentUrl, 0);
-  });
-
-  testWidgets('evaluate Javascript', (WidgetTester tester) async {
-    late WebViewController controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://flutter.io',
-        javascriptMode: JavascriptMode.unrestricted,
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-    expect(
-        await controller.evaluateJavascript("fake js string"), "fake js string",
-        reason: 'should get the argument');
-  });
-
-  testWidgets('evaluate Javascript with JavascriptMode disabled',
-      (WidgetTester tester) async {
-    late WebViewController controller;
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://flutter.io',
-        javascriptMode: JavascriptMode.disabled,
-        onWebViewCreated: (WebViewController webViewController) {
-          controller = webViewController;
-        },
-      ),
-    );
-    expect(
-      () => controller.evaluateJavascript('fake js string'),
-      throwsA(anything),
-    );
-  });
-
-  testWidgets('Cookies can be cleared once', (WidgetTester tester) async {
-    await tester.pumpWidget(
-      const WebView(
-        initialUrl: 'https://flutter.io',
-      ),
-    );
-    final CookieManager cookieManager = CookieManager();
-    final bool hasCookies = await cookieManager.clearCookies();
-    expect(hasCookies, true);
-  });
-
-  testWidgets('Second cookie clear does not have cookies',
-      (WidgetTester tester) async {
-    await tester.pumpWidget(
-      const WebView(
-        initialUrl: 'https://flutter.io',
-      ),
-    );
-    final CookieManager cookieManager = CookieManager();
-    final bool hasCookies = await cookieManager.clearCookies();
-    expect(hasCookies, true);
-    final bool hasCookiesSecond = await cookieManager.clearCookies();
-    expect(hasCookiesSecond, false);
-  });
-
-  testWidgets('Initial JavaScript channels', (WidgetTester tester) async {
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        javascriptChannels: <JavascriptChannel>{
-          JavascriptChannel(
-              name: 'Tts', onMessageReceived: (JavascriptMessage msg) {}),
-          JavascriptChannel(
-              name: 'Alarm', onMessageReceived: (JavascriptMessage msg) {}),
-        },
-      ),
-    );
-
-    final FakePlatformWebView platformWebView =
-        fakePlatformViewsController.lastCreatedView!;
-
-    expect(platformWebView.javascriptChannelNames,
-        unorderedEquals(<String>['Tts', 'Alarm']));
-  });
-
-  test('Only valid JavaScript channel names are allowed', () {
-    final JavascriptMessageHandler noOp = (JavascriptMessage msg) {};
-    JavascriptChannel(name: 'Tts1', onMessageReceived: noOp);
-    JavascriptChannel(name: '_Alarm', onMessageReceived: noOp);
-    JavascriptChannel(name: 'foo_bar_', onMessageReceived: noOp);
-
-    VoidCallback createChannel(String name) {
-      return () {
-        JavascriptChannel(name: name, onMessageReceived: noOp);
-      };
-    }
-
-    expect(createChannel('1Alarm'), throwsAssertionError);
-    expect(createChannel('foo.bar'), throwsAssertionError);
-    expect(createChannel(''), throwsAssertionError);
-  });
-
-  testWidgets('Unique JavaScript channel names are required',
-      (WidgetTester tester) async {
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        javascriptChannels: <JavascriptChannel>{
-          JavascriptChannel(
-              name: 'Alarm', onMessageReceived: (JavascriptMessage msg) {}),
-          JavascriptChannel(
-              name: 'Alarm', onMessageReceived: (JavascriptMessage msg) {}),
-        },
-      ),
-    );
-    expect(tester.takeException(), isNot(null));
-  });
-
-  testWidgets('JavaScript channels update', (WidgetTester tester) async {
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        javascriptChannels: <JavascriptChannel>{
-          JavascriptChannel(
-              name: 'Tts', onMessageReceived: (JavascriptMessage msg) {}),
-          JavascriptChannel(
-              name: 'Alarm', onMessageReceived: (JavascriptMessage msg) {}),
-        },
-      ),
-    );
-
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        javascriptChannels: <JavascriptChannel>{
-          JavascriptChannel(
-              name: 'Tts', onMessageReceived: (JavascriptMessage msg) {}),
-          JavascriptChannel(
-              name: 'Alarm2', onMessageReceived: (JavascriptMessage msg) {}),
-          JavascriptChannel(
-              name: 'Alarm3', onMessageReceived: (JavascriptMessage msg) {}),
-        },
-      ),
-    );
-
-    final FakePlatformWebView platformWebView =
-        fakePlatformViewsController.lastCreatedView!;
-
-    expect(platformWebView.javascriptChannelNames,
-        unorderedEquals(<String>['Tts', 'Alarm2', 'Alarm3']));
-  });
-
-  testWidgets('Remove all JavaScript channels and then add',
-      (WidgetTester tester) async {
-    // This covers a specific bug we had where after updating javascriptChannels to null,
-    // updating it again with a subset of the previously registered channels fails as the
-    // widget's cache of current channel wasn't properly updated when updating javascriptChannels to
-    // null.
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        javascriptChannels: <JavascriptChannel>{
-          JavascriptChannel(
-              name: 'Tts', onMessageReceived: (JavascriptMessage msg) {}),
-        },
-      ),
-    );
-
-    await tester.pumpWidget(
-      const WebView(
-        initialUrl: 'https://youtube.com',
-      ),
-    );
-
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        javascriptChannels: <JavascriptChannel>{
-          JavascriptChannel(
-              name: 'Tts', onMessageReceived: (JavascriptMessage msg) {}),
-        },
-      ),
-    );
-
-    final FakePlatformWebView platformWebView =
-        fakePlatformViewsController.lastCreatedView!;
-
-    expect(platformWebView.javascriptChannelNames,
-        unorderedEquals(<String>['Tts']));
-  });
-
-  testWidgets('JavaScript channel messages', (WidgetTester tester) async {
-    final List<String> ttsMessagesReceived = <String>[];
-    final List<String> alarmMessagesReceived = <String>[];
-    await tester.pumpWidget(
-      WebView(
-        initialUrl: 'https://youtube.com',
-        javascriptChannels: <JavascriptChannel>{
-          JavascriptChannel(
-              name: 'Tts',
-              onMessageReceived: (JavascriptMessage msg) {
-                ttsMessagesReceived.add(msg.message);
-              }),
-          JavascriptChannel(
-              name: 'Alarm',
-              onMessageReceived: (JavascriptMessage msg) {
-                alarmMessagesReceived.add(msg.message);
-              }),
-        },
-      ),
-    );
-
-    final FakePlatformWebView platformWebView =
-        fakePlatformViewsController.lastCreatedView!;
-
-    expect(ttsMessagesReceived, isEmpty);
-    expect(alarmMessagesReceived, isEmpty);
-
-    platformWebView.fakeJavascriptPostMessage('Tts', 'Hello');
-    platformWebView.fakeJavascriptPostMessage('Tts', 'World');
-
-    expect(ttsMessagesReceived, <String>['Hello', 'World']);
-  });
-
-  group('$PageStartedCallback', () {
-    testWidgets('onPageStarted is not null', (WidgetTester tester) async {
-      String? returnedUrl;
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onPageStarted: (String url) {
-          returnedUrl = url;
-        },
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      platformWebView.fakeOnPageStartedCallback();
-
-      expect(platformWebView.currentUrl, returnedUrl);
-    });
-
-    testWidgets('onPageStarted is null', (WidgetTester tester) async {
-      await tester.pumpWidget(const WebView(
-        initialUrl: 'https://youtube.com',
-        onPageStarted: null,
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      // The platform side will always invoke a call for onPageStarted. This is
-      // to test that it does not crash on a null callback.
-      platformWebView.fakeOnPageStartedCallback();
-    });
-
-    testWidgets('onPageStarted changed', (WidgetTester tester) async {
-      String? returnedUrl;
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onPageStarted: (String url) {},
-      ));
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onPageStarted: (String url) {
-          returnedUrl = url;
-        },
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      platformWebView.fakeOnPageStartedCallback();
-
-      expect(platformWebView.currentUrl, returnedUrl);
-    });
-  });
-
-  group('$PageFinishedCallback', () {
-    testWidgets('onPageFinished is not null', (WidgetTester tester) async {
-      String? returnedUrl;
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onPageFinished: (String url) {
-          returnedUrl = url;
-        },
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      platformWebView.fakeOnPageFinishedCallback();
-
-      expect(platformWebView.currentUrl, returnedUrl);
-    });
-
-    testWidgets('onPageFinished is null', (WidgetTester tester) async {
-      await tester.pumpWidget(const WebView(
-        initialUrl: 'https://youtube.com',
-        onPageFinished: null,
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      // The platform side will always invoke a call for onPageFinished. This is
-      // to test that it does not crash on a null callback.
-      platformWebView.fakeOnPageFinishedCallback();
-    });
-
-    testWidgets('onPageFinished changed', (WidgetTester tester) async {
-      String? returnedUrl;
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onPageFinished: (String url) {},
-      ));
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onPageFinished: (String url) {
-          returnedUrl = url;
-        },
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      platformWebView.fakeOnPageFinishedCallback();
-
-      expect(platformWebView.currentUrl, returnedUrl);
-    });
-  });
-
-  group('$PageLoadingCallback', () {
-    testWidgets('onLoadingProgress is not null', (WidgetTester tester) async {
-      int? loadingProgress;
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onProgress: (int progress) {
-          loadingProgress = progress;
-        },
-      ));
-
-      final FakePlatformWebView? platformWebView =
-          fakePlatformViewsController.lastCreatedView;
-
-      platformWebView?.fakeOnProgressCallback(50);
-
-      expect(loadingProgress, 50);
-    });
-
-    testWidgets('onLoadingProgress is null', (WidgetTester tester) async {
-      await tester.pumpWidget(const WebView(
-        initialUrl: 'https://youtube.com',
-        onProgress: null,
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      // This is to test that it does not crash on a null callback.
-      platformWebView.fakeOnProgressCallback(50);
-    });
-
-    testWidgets('onLoadingProgress changed', (WidgetTester tester) async {
-      int? loadingProgress;
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onProgress: (int progress) {},
-      ));
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        onProgress: (int progress) {
-          loadingProgress = progress;
-        },
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      platformWebView.fakeOnProgressCallback(50);
-
-      expect(loadingProgress, 50);
-    });
-  });
-
-  group('navigationDelegate', () {
-    testWidgets('hasNavigationDelegate', (WidgetTester tester) async {
-      await tester.pumpWidget(const WebView(
-        initialUrl: 'https://youtube.com',
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      expect(platformWebView.hasNavigationDelegate, false);
-
-      await tester.pumpWidget(WebView(
-        initialUrl: 'https://youtube.com',
-        navigationDelegate: (NavigationRequest r) =>
-            NavigationDecision.navigate,
-      ));
-
-      expect(platformWebView.hasNavigationDelegate, true);
-    });
-
-    testWidgets('Block navigation', (WidgetTester tester) async {
-      final List<NavigationRequest> navigationRequests = <NavigationRequest>[];
-
-      await tester.pumpWidget(WebView(
-          initialUrl: 'https://youtube.com',
-          navigationDelegate: (NavigationRequest request) {
-            navigationRequests.add(request);
-            // Only allow navigating to https://flutter.dev
-            return request.url == 'https://flutter.dev'
-                ? NavigationDecision.navigate
-                : NavigationDecision.prevent;
-          }));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      expect(platformWebView.hasNavigationDelegate, true);
-
-      platformWebView.fakeNavigate('https://www.google.com');
-      // The navigation delegate only allows navigation to https://flutter.dev
-      // so we should still be in https://youtube.com.
-      expect(platformWebView.currentUrl, 'https://youtube.com');
-      expect(navigationRequests.length, 1);
-      expect(navigationRequests[0].url, 'https://www.google.com');
-      expect(navigationRequests[0].isForMainFrame, true);
-
-      platformWebView.fakeNavigate('https://flutter.dev');
-      await tester.pump();
-      expect(platformWebView.currentUrl, 'https://flutter.dev');
-    });
-  });
-
-  group('debuggingEnabled', () {
-    testWidgets('enable debugging', (WidgetTester tester) async {
-      await tester.pumpWidget(const WebView(
-        debuggingEnabled: true,
-      ));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      expect(platformWebView.debuggingEnabled, true);
-    });
-
-    testWidgets('defaults to false', (WidgetTester tester) async {
-      await tester.pumpWidget(const WebView());
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      expect(platformWebView.debuggingEnabled, false);
-    });
-
-    testWidgets('can be changed', (WidgetTester tester) async {
-      final GlobalKey key = GlobalKey();
-      await tester.pumpWidget(WebView(key: key));
-
-      final FakePlatformWebView platformWebView =
-          fakePlatformViewsController.lastCreatedView!;
-
-      await tester.pumpWidget(WebView(
-        key: key,
-        debuggingEnabled: true,
-      ));
-
-      expect(platformWebView.debuggingEnabled, true);
-
-      await tester.pumpWidget(WebView(
-        key: key,
-        debuggingEnabled: false,
-      ));
-
-      expect(platformWebView.debuggingEnabled, false);
-    });
-  });
-
-  group('Custom platform implementation', () {
-    setUpAll(() {
-      WebView.platform = MyWebViewPlatform();
-    });
-    tearDownAll(() {
-      WebView.platform = null;
-    });
-
-    testWidgets('creation', (WidgetTester tester) async {
-      await tester.pumpWidget(
-        const WebView(
-          initialUrl: 'https://youtube.com',
-          gestureNavigationEnabled: true,
-        ),
-      );
-
-      final MyWebViewPlatform builder = WebView.platform as MyWebViewPlatform;
-      final MyWebViewPlatformController platform = builder.lastPlatformBuilt!;
-
-      expect(
-          platform.creationParams,
-          MatchesCreationParams(CreationParams(
-            initialUrl: 'https://youtube.com',
-            webSettings: WebSettings(
-              javascriptMode: JavascriptMode.disabled,
-              hasNavigationDelegate: false,
-              debuggingEnabled: false,
-              userAgent: WebSetting<String?>.of(null),
-              gestureNavigationEnabled: true,
-            ),
-          )));
-    });
-
-    testWidgets('loadUrl', (WidgetTester tester) async {
-      late WebViewController controller;
-      await tester.pumpWidget(
-        WebView(
-          initialUrl: 'https://youtube.com',
-          onWebViewCreated: (WebViewController webViewController) {
-            controller = webViewController;
-          },
-        ),
-      );
-
-      final MyWebViewPlatform builder = WebView.platform as MyWebViewPlatform;
-      final MyWebViewPlatformController platform = builder.lastPlatformBuilt!;
-
-      final Map<String, String> headers = <String, String>{
-        'header': 'value',
-      };
-
-      await controller.loadUrl('https://google.com', headers: headers);
-
-      expect(platform.lastUrlLoaded, 'https://google.com');
-      expect(platform.lastRequestHeaders, headers);
-    });
-  });
-  testWidgets('Set UserAgent', (WidgetTester tester) async {
-    await tester.pumpWidget(const WebView(
-      initialUrl: 'https://youtube.com',
-      javascriptMode: JavascriptMode.unrestricted,
-    ));
-
-    final FakePlatformWebView platformWebView =
-        fakePlatformViewsController.lastCreatedView!;
-
-    expect(platformWebView.userAgent, isNull);
-
-    await tester.pumpWidget(const WebView(
-      initialUrl: 'https://youtube.com',
-      javascriptMode: JavascriptMode.unrestricted,
-      userAgent: 'UA',
-    ));
-
-    expect(platformWebView.userAgent, 'UA');
-  });
-}
-
-class FakePlatformWebView {
-  FakePlatformWebView(int? id, Map<dynamic, dynamic> params) {
-    if (params.containsKey('initialUrl')) {
-      final String? initialUrl = params['initialUrl'];
-      if (initialUrl != null) {
-        history.add(initialUrl);
-        currentPosition++;
-      }
-    }
-    if (params.containsKey('javascriptChannelNames')) {
-      javascriptChannelNames =
-          List<String>.from(params['javascriptChannelNames']);
-    }
-    javascriptMode = JavascriptMode.values[params['settings']['jsMode']];
-    hasNavigationDelegate =
-        params['settings']['hasNavigationDelegate'] ?? false;
-    debuggingEnabled = params['settings']['debuggingEnabled'];
-    userAgent = params['settings']['userAgent'];
-    channel = MethodChannel(
-        'plugins.flutter.io/webview_$id', const StandardMethodCodec());
-    channel.setMockMethodCallHandler(onMethodCall);
-  }
-
-  late MethodChannel channel;
-
-  List<String?> history = <String?>[];
-  int currentPosition = -1;
-  int amountOfReloadsOnCurrentUrl = 0;
-  bool hasCache = true;
-
-  String? get currentUrl => history.isEmpty ? null : history[currentPosition];
-  JavascriptMode? javascriptMode;
-  List<String>? javascriptChannelNames;
-
-  bool? hasNavigationDelegate;
-  bool? debuggingEnabled;
-  String? userAgent;
-
-  Future<dynamic> onMethodCall(MethodCall call) {
-    switch (call.method) {
-      case 'loadUrl':
-        final Map<dynamic, dynamic> request = call.arguments;
-        _loadUrl(request['url']);
-        return Future<void>.sync(() {});
-      case 'updateSettings':
-        if (call.arguments['jsMode'] != null) {
-          javascriptMode = JavascriptMode.values[call.arguments['jsMode']];
-        }
-        if (call.arguments['hasNavigationDelegate'] != null) {
-          hasNavigationDelegate = call.arguments['hasNavigationDelegate'];
-        }
-        if (call.arguments['debuggingEnabled'] != null) {
-          debuggingEnabled = call.arguments['debuggingEnabled'];
-        }
-        userAgent = call.arguments['userAgent'];
-        break;
-      case 'canGoBack':
-        return Future<bool>.sync(() => currentPosition > 0);
-      case 'canGoForward':
-        return Future<bool>.sync(() => currentPosition < history.length - 1);
-      case 'goBack':
-        currentPosition = max(-1, currentPosition - 1);
-        return Future<void>.sync(() {});
-      case 'goForward':
-        currentPosition = min(history.length - 1, currentPosition + 1);
-        return Future<void>.sync(() {});
-      case 'reload':
-        amountOfReloadsOnCurrentUrl++;
-        return Future<void>.sync(() {});
-      case 'currentUrl':
-        return Future<String?>.value(currentUrl);
-      case 'evaluateJavascript':
-        return Future<dynamic>.value(call.arguments);
-      case 'addJavascriptChannels':
-        final List<String> channelNames = List<String>.from(call.arguments);
-        javascriptChannelNames!.addAll(channelNames);
-        break;
-      case 'removeJavascriptChannels':
-        final List<String> channelNames = List<String>.from(call.arguments);
-        javascriptChannelNames!
-            .removeWhere((String channel) => channelNames.contains(channel));
-        break;
-      case 'clearCache':
-        hasCache = false;
-        return Future<void>.sync(() {});
-    }
-    return Future<void>.sync(() {});
-  }
-
-  void fakeJavascriptPostMessage(String jsChannel, String message) {
-    final StandardMethodCodec codec = const StandardMethodCodec();
-    final Map<String, dynamic> arguments = <String, dynamic>{
-      'channel': jsChannel,
-      'message': message
-    };
-    final ByteData data = codec
-        .encodeMethodCall(MethodCall('javascriptChannelMessage', arguments));
-    _ambiguate(ServicesBinding.instance)!
-        .defaultBinaryMessenger
-        .handlePlatformMessage(channel.name, data, (ByteData? data) {});
-  }
-
-  // Fakes a main frame navigation that was initiated by the webview, e.g when
-  // the user clicks a link in the currently loaded page.
-  void fakeNavigate(String url) {
-    if (!hasNavigationDelegate!) {
-      print('no navigation delegate');
-      _loadUrl(url);
-      return;
-    }
-    final StandardMethodCodec codec = const StandardMethodCodec();
-    final Map<String, dynamic> arguments = <String, dynamic>{
-      'url': url,
-      'isForMainFrame': true
-    };
-    final ByteData data =
-        codec.encodeMethodCall(MethodCall('navigationRequest', arguments));
-    _ambiguate(ServicesBinding.instance)!
-        .defaultBinaryMessenger
-        .handlePlatformMessage(channel.name, data, (ByteData? data) {
-      final bool allow = codec.decodeEnvelope(data!);
-      if (allow) {
-        _loadUrl(url);
-      }
-    });
-  }
-
-  void fakeOnPageStartedCallback() {
-    final StandardMethodCodec codec = const StandardMethodCodec();
-
-    final ByteData data = codec.encodeMethodCall(MethodCall(
-      'onPageStarted',
-      <dynamic, dynamic>{'url': currentUrl},
-    ));
-
-    _ambiguate(ServicesBinding.instance)!
-        .defaultBinaryMessenger
-        .handlePlatformMessage(
-          channel.name,
-          data,
-          (ByteData? data) {},
-        );
-  }
-
-  void fakeOnPageFinishedCallback() {
-    final StandardMethodCodec codec = const StandardMethodCodec();
-
-    final ByteData data = codec.encodeMethodCall(MethodCall(
-      'onPageFinished',
-      <dynamic, dynamic>{'url': currentUrl},
-    ));
-
-    _ambiguate(ServicesBinding.instance)!
-        .defaultBinaryMessenger
-        .handlePlatformMessage(
-          channel.name,
-          data,
-          (ByteData? data) {},
-        );
-  }
-
-  void fakeOnProgressCallback(int progress) {
-    final StandardMethodCodec codec = const StandardMethodCodec();
-
-    final ByteData data = codec.encodeMethodCall(MethodCall(
-      'onProgress',
-      <dynamic, dynamic>{'progress': progress},
-    ));
-
-    _ambiguate(ServicesBinding.instance)!
-        .defaultBinaryMessenger
-        .handlePlatformMessage(channel.name, data, (ByteData? data) {});
-  }
-
-  void _loadUrl(String? url) {
-    history = history.sublist(0, currentPosition + 1);
-    history.add(url);
-    currentPosition++;
-    amountOfReloadsOnCurrentUrl = 0;
-  }
-}
-
-class _FakePlatformViewsController {
-  FakePlatformWebView? lastCreatedView;
-
-  Future<dynamic> fakePlatformViewsMethodHandler(MethodCall call) {
-    switch (call.method) {
-      case 'create':
-        final Map<dynamic, dynamic> args = call.arguments;
-        final Map<dynamic, dynamic> params = _decodeParams(args['params'])!;
-        lastCreatedView = FakePlatformWebView(
-          args['id'],
-          params,
-        );
-        return Future<int>.sync(() => 1);
-      default:
-        return Future<void>.sync(() {});
-    }
-  }
-
-  void reset() {
-    lastCreatedView = null;
-  }
-}
-
-Map<dynamic, dynamic>? _decodeParams(Uint8List paramsMessage) {
-  final ByteBuffer buffer = paramsMessage.buffer;
-  final ByteData messageBytes = buffer.asByteData(
-    paramsMessage.offsetInBytes,
-    paramsMessage.lengthInBytes,
-  );
-  return const StandardMessageCodec().decodeMessage(messageBytes);
-}
-
-class _FakeCookieManager {
-  _FakeCookieManager() {
-    final MethodChannel channel = const MethodChannel(
-      'plugins.flutter.io/cookie_manager',
-      StandardMethodCodec(),
-    );
-    channel.setMockMethodCallHandler(onMethodCall);
-  }
-
-  bool hasCookies = true;
-
-  Future<bool> onMethodCall(MethodCall call) {
-    switch (call.method) {
-      case 'clearCookies':
-        bool hadCookies = false;
-        if (hasCookies) {
-          hadCookies = true;
-          hasCookies = false;
-        }
-        return Future<bool>.sync(() {
-          return hadCookies;
-        });
-    }
-    return Future<bool>.sync(() => true);
-  }
-
-  void reset() {
-    hasCookies = true;
-  }
-}
-
-class MyWebViewPlatform implements WebViewPlatform {
-  MyWebViewPlatformController? lastPlatformBuilt;
-
-  @override
-  Widget build({
-    BuildContext? context,
-    CreationParams? creationParams,
-    required WebViewPlatformCallbacksHandler webViewPlatformCallbacksHandler,
-    WebViewPlatformCreatedCallback? onWebViewPlatformCreated,
-    Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers,
-  }) {
-    assert(onWebViewPlatformCreated != null);
-    lastPlatformBuilt = MyWebViewPlatformController(
-        creationParams, gestureRecognizers, webViewPlatformCallbacksHandler);
-    onWebViewPlatformCreated!(lastPlatformBuilt);
-    return Container();
-  }
-
-  @override
-  Future<bool> clearCookies() {
-    return Future<bool>.sync(() => true);
-  }
-}
-
-class MyWebViewPlatformController extends WebViewPlatformController {
-  MyWebViewPlatformController(this.creationParams, this.gestureRecognizers,
-      WebViewPlatformCallbacksHandler platformHandler)
-      : super(platformHandler);
-
-  CreationParams? creationParams;
-  Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers;
-
-  String? lastUrlLoaded;
-  Map<String, String>? lastRequestHeaders;
-
-  @override
-  Future<void> loadUrl(String url, Map<String, String>? headers) async {
-    equals(1, 1);
-    lastUrlLoaded = url;
-    lastRequestHeaders = headers;
-  }
-}
-
-class MatchesWebSettings extends Matcher {
-  MatchesWebSettings(this._webSettings);
-
-  final WebSettings? _webSettings;
-
-  @override
-  Description describe(Description description) =>
-      description.add('$_webSettings');
-
-  @override
-  bool matches(
-      covariant WebSettings webSettings, Map<dynamic, dynamic> matchState) {
-    return _webSettings!.javascriptMode == webSettings.javascriptMode &&
-        _webSettings!.hasNavigationDelegate ==
-            webSettings.hasNavigationDelegate &&
-        _webSettings!.debuggingEnabled == webSettings.debuggingEnabled &&
-        _webSettings!.gestureNavigationEnabled ==
-            webSettings.gestureNavigationEnabled &&
-        _webSettings!.userAgent == webSettings.userAgent;
-  }
-}
-
-class MatchesCreationParams extends Matcher {
-  MatchesCreationParams(this._creationParams);
-
-  final CreationParams _creationParams;
-
-  @override
-  Description describe(Description description) =>
-      description.add('$_creationParams');
-
-  @override
-  bool matches(covariant CreationParams creationParams,
-      Map<dynamic, dynamic> matchState) {
-    return _creationParams.initialUrl == creationParams.initialUrl &&
-        MatchesWebSettings(_creationParams.webSettings)
-            .matches(creationParams.webSettings!, matchState) &&
-        orderedEquals(_creationParams.javascriptChannelNames)
-            .matches(creationParams.javascriptChannelNames, matchState);
-  }
-}
-
-/// This allows a value of type T or T? to be treated as a value of type T?.
-///
-/// We use this so that APIs that have become non-nullable can still be used
-/// with `!` and `?` on the stable branch.
-// TODO(ianh): Remove this once we roll stable in late 2021.
-T? _ambiguate<T>(T? value) => value;
-- 
2.19.2

